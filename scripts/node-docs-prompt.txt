# Block Reference Documentation

---
## draft/draft.mdx

---
id: draft
title: Multi-Modal Draft Block
description: Generate various document types using AI-powered drafting capabilities with text and image inputs
sidebarTitle: Draft
---

## Overview

The Multi-Modal Draft Block leverages AI to generate various types of documents based on user prompts, context, and images. It offers a set of example templates for common document types and an optimized custom template feature for more specific drafting needs. This block intelligently incorporates both textual and visual information to create comprehensive and context-aware documents.
## Inputs

<ParamField path="systemPrompt" type="string" optional>
  The system prompt to send to the model. This provides high-level instructions or context for the AI model.
</ParamField>

<ParamField path="prompt" type="string" optional>
  The prompt to send to the model. Only available when "Use Prompt Input" is enabled.
</ParamField>

<ParamField path="images" type="image[]" optional>
  An array of images to be analyzed and incorporated into the document. Only available when "Multi-Modal" is enabled.
</ParamField>

<ParamField path="(Template Variables)" type="string" optional>
  When using templates, additional inputs are dynamically generated based on the template's variables. These inputs are used to customize the template output.
</ParamField>

## Outputs

<ResponseField name="output" type="string">
  The generated document draft based on the inputs and template.
</ResponseField>

<ResponseField name="duration" type="number">
  The time taken to generate the draft in milliseconds.
</ResponseField>

<ResponseField name="wordCount" type="number">
  The number of words in the generated draft.
</ResponseField>

## Editor Settings

<ParamField path="AI Model" type="string" default="gpt-4">
  The AI model to use for document generation. Available models are dynamically populated based on your configuration.
</ParamField>

<ParamField path="Multi-Modal" type="boolean" default={false}>
  When enabled, allows the block to process both text and image inputs to generate the output.
</ParamField>

<ParamField path="Use Prompt Input" type="boolean" default={false}>
  When enabled, allows direct prompt input instead of using templates.
</ParamField>

<ParamField path="Drafting Prompt Template" type="string" default="Legal Brief">
  Select from predefined templates: Legal Brief, Research Report, Email, or Letter. Only available when "Use Prompt Input" is disabled.
</ParamField>

<ParamField path="Word Count" type="number" default={800} min={500} max={2000}>
  The target word count for the generated document. Only available when "Use Prompt Input" is disabled.
</ParamField>

## Example Templates

The Draft Block includes the following pre-configured templates:

- Legal Brief
- Research Report
- Email
- Letter

Each template is optimized for its specific use case and includes relevant variables for customization.

## Example: Using a Template

1. Add a Draft Block to your flow
2. Select your desired template from "Drafting Prompt Template"
3. Configure the word count and other settings
4. Connect required inputs based on the template variables
5. Run the flow to generate your document
## Error Handling

The Draft Block includes robust error handling with automatic retries for:
- API rate limit exceeded (429 errors)
- API timeouts (408 errors)
- Network failures
- Other recoverable errors

The block will display appropriate error messages and retry automatically when possible.

<Warning>
  The block has a maximum retry time of 5 minutes and will throw an error if unable to complete within this timeframe.
</Warning>

## FAQ

<AccordionGroup>
  <Accordion title="How does Multi-Modal drafting work?">
    When Multi-Modal is enabled, the block can process both text and image inputs simultaneously. The AI model analyzes the images and incorporates relevant visual information into the generated document.
  </Accordion>

  <Accordion title="What's the difference between using a template and direct prompt input?">
    Templates provide structured, pre-configured prompts optimized for specific document types. Direct prompt input gives you more flexibility but requires you to craft your own prompting strategy.
  </Accordion>

  <Accordion title="How are retries handled?">
    The block automatically retries failed attempts with exponential backoff, with delays between 500ms and 5000ms. It handles rate limits and timeouts gracefully while keeping you informed of retry status.
  </Accordion>
</AccordionGroup>

## See Also

- [Ask AI Block](/block-reference/ai/ask-ai)
- [Text Block](/block-reference/data/text)
- [Image Block](/block-reference/data/image)
- [Object Block](/block-reference/data/object)

---

---
## draft/text-to-file.mdx

---
id: text-to-file
title: Text to File Block
description: Convert text or markdown into styled document files
sidebarTitle: Text to File
---

## Overview

The Text to File Block transforms plain text or markdown into styled document files. This block is particularly useful for creating professional-looking documents from simple text input. It supports multiple output formats, allowing you to generate files that can be easily shared or further edited in popular document processing applications.
## Inputs

<ParamField path="text" type="string" required>
  The text to convert to files. The input will be coerced to a string if needed.
</ParamField>

## Outputs

<ResponseField name="files" type="file[]">
  The converted file output in the specified formats.
</ResponseField>

<ResponseField name="duration" type="number">
  The time taken to process the conversion in milliseconds.
</ResponseField>

## Editor Settings

<ParamField path="formats" type="string[]" default={["pdf", "docx"]}>
  The output file formats to generate. Supported formats:
  - pdf: Portable Document Format
  - docx: Microsoft Word Document
</ParamField>

## What is Markdown?

Markdown is a simple way to format text that looks great on any device. It doesn't do anything fancy like change font sizes or colors, but it does make it easy to create:

- **Bold** or *italic* text
- Lists (like this one!)
- Headers of different sizes
- Links to websites
- And more!

You don't need to know markdown to use this block, but if you do, you can create more structured and styled documents easily.

## Example: Creating a PDF Report

1. Add a Text to File block to your flow.
2. Connect a Text block with your report content to the `text` input. You can use markdown formatting if desired.
3. In the block settings, select "PDF" as the Output Format.
4. Run your flow. The block will output a PDF file containing your styled report.
## Error Handling

The block will retry failed attempts with the following behavior:
- Maximum retry time of 5 minutes
- Exponential backoff starting at 500ms up to 5000ms
- Traces failed attempts for debugging
- Aborts if the process is cancelled

Common errors include:
- No Docme endpoint configured in settings
- Empty or missing input text
- API rate limit exceeded (429)
- Internal service errors (500)

<Warning>
  Always ensure your environment is correctly configured with a Docme endpoint and that input text is properly formatted.
</Warning>

## FAQ

<AccordionGroup>
  <Accordion title="Do I need to know markdown to use this block?">
    No, you don't need to know markdown. You can input plain text, and the block will still convert it into a styled document. However, knowing markdown can help you create more structured and formatted documents easily.
  </Accordion>

  <Accordion title="Can I generate multiple file formats at once?">
    Yes, you can select multiple output formats in the block settings. The block will generate a file for each selected format and return them in the output array.
  </Accordion>

  <Accordion title="How does the block handle images or other media in the input text?">
    If you're using markdown and include image links, the block will attempt to download and embed these images in the output files. However, other media types may not be supported, depending on the output format.
  </Accordion>
</AccordionGroup>

## See Also

- [Text Block](/block-reference/data/text)
- [File Block](/block-reference/data/file)
- [Draft Block](/block-reference/draft/draft)

---

---
## draft/populate-template.mdx

---
id: populate-template
title: Populate Template Block
description: Intelligently fill a pre-built template using AI, handling various content types including text, tables, and images
sidebarTitle: Populate Template
---

## Overview

The Populate Template Block is a powerful tool that combines pre-built templates with AI capabilities to generate comprehensive, context-aware documents. This block takes a template created in our template editor and uses a connected AI model to intelligently fill in the content based on the supplied context and the structure of the document itself.
## Inputs

<ParamField path="systemPrompt" type="string" optional>
  The system prompt to send to the model. This provides high-level instructions or context for the AI model.
</ParamField>

<ParamField path="context" type="string" required>
  The context to support the population of the template. This can include background information, specific requirements, or any other relevant details.
</ParamField>

<ParamField path="images" type="image[]" optional>
  Any images to be used to populate the template. These can be referenced and incorporated into the final document.
</ParamField>

## Outputs

<ResponseField name="document" type="file">
  The completed template document with all fields populated.
</ResponseField>

<ResponseField name="duration" type="number">
  The time taken to generate the document in milliseconds.
</ResponseField>

## Editor Settings

<ParamField path="templateId" type="dropdown">
  The template you wish to populate. Select from available templates in your workspace.
</ParamField>

<ParamField path="model" type="dropdown" customElement="LLMDropdown">
  The AI model to use for generating content. Options are dynamically populated based on available models.
</ParamField>

<ParamField path="temperature" type="number" default={0.3} min={0} max={2} step={0.1}>
  What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
</ParamField>

<ParamField path="maxTokens" type="number" default={16384}>
  The maximum number of tokens to generate in the chat completion.
</ParamField>

## Example: Generating a Business Report

1. Create a template in the template editor with placeholders for your content
2. Add a Populate Template block to your flow
3. Select your template from the Templates dropdown
4. Configure the AI Model and parameters as needed
5. Connect your context and any images to the corresponding inputs
6. Run your flow to generate the populated document
## Error Handling

The block will retry failed attempts with the following behavior:
- Maximum retry time of 2 minutes
- Exponential backoff starting at 500ms up to 5000ms
- Traces failed attempts for debugging
- Aborts if the process is cancelled

Common errors include:
- Missing template provider
- Missing LLM provider
- Missing file provider
- No template ID selected
- Failed to populate template fields

<Warning>
  Always ensure you have the necessary providers configured and a template selected before running the block.
</Warning>

## FAQ

<AccordionGroup>
  <Accordion title="What happens if template fields can't be populated?">
    If the block fails to populate any template fields, it will throw an error. Fields that are successfully populated will be included in the output document.
  </Accordion>

  <Accordion title="Can I customize the AI model parameters?">
    Yes, you can adjust the temperature and max tokens settings to control the AI's output. Lower temperature values (0.2-0.3) produce more focused results, while higher values produce more creative ones.
  </Accordion>

  <Accordion title="How are images handled in templates?">
    Images provided through the images input can be referenced and incorporated into the template. The AI model can use these images for context when populating related fields.
  </Accordion>
</AccordionGroup>

## See Also

- [Draft Block](/block-reference/draft/draft)
- [Text Block](/block-reference/data/text)
- [Image Block](/block-reference/data/image)

---

---
## draft/table-to-file.mdx

---
id: table-to-file
title: Table to File Block
description: Convert tabular data into a CSV file
sidebarTitle: Table to File
---

## Overview

The Table to File Block converts tabular data into a CSV (Comma-Separated Values) file. This block is particularly useful when you need to export data from your flow in a widely compatible format for further analysis or sharing.
## Inputs

<ParamField path="table" type="table" required>
  The table to convert. The input will be coerced to a table format if needed.
</ParamField>

## Outputs

<ResponseField name="file" type="file">
  The converted file output in CSV format.
</ResponseField>

<ResponseField name="duration" type="number">
  The time taken to process the conversion in milliseconds.
</ResponseField>

## Editor Settings

<ParamField path="formats" type="string[]" default={["csv"]}>
  The output file formats to generate. Currently only supports CSV format.
</ParamField>

## Example: Exporting a Table to CSV

1. Add a Table to File block to your flow.
2. Connect your input table to the `table` input of the Table to File block.
3. Run your flow. The block will output a CSV file containing your table data.
## Error Handling

The block will error if:
- No Docme endpoint is configured in settings
- The input table is invalid or cannot be coerced to a table format

<Warning>
  Ensure that the input table data is properly structured and that your environment is correctly configured with a Docme endpoint.
</Warning>

## FAQ

<AccordionGroup>
  <Accordion title="What file formats are supported?">
    Currently, the Table to File block only supports CSV (Comma-Separated Values) format. Additional formats may be added in future updates.
  </Accordion>

  <Accordion title="How does the block handle data type conversion?">
    The block will attempt to coerce the input data into a table format if it's not already in the correct format. This provides flexibility in handling different input data structures.
  </Accordion>
</AccordionGroup>

## See Also

- [Table Block](/block-reference/data/table)
- [File Block](/block-reference/data/file)
- [Draft Block](/block-reference/draft/draft)

---

---
## advanced/subflow.mdx

---
id: subflow
title: Subflow Block
description: Execute another flow within the current flow for reusable logic and modular design
sidebarTitle: Subflow
---

## Overview

The Subflow Block allows you to execute another flow within the current flow. This powerful feature enables you to reuse logic across multiple flows, break down complex flows into smaller pieces, and create modular workflow designs.

<Note>
  Subflows must be within the same project and cannot reference flows from different projects.
</Note>
## Inputs

<ParamField path="(Dynamic Inputs)" type="any">
  The inputs are dynamically generated based on the Input Blocks configured in the selected subflow. Each Input Block in the subflow creates a corresponding input port on the Subflow Block.
</ParamField>

<ParamField path="Wait For" type="any">
  Only shown when "Wait For Input" is enabled. Used to delay execution until this input is ready.
</ParamField>

## Outputs

<ResponseField name="(Dynamic Outputs)" type="any">
  The outputs are dynamically generated based on the Output Blocks configured in the selected subflow. Each Output Block in the subflow creates a corresponding output port on the Subflow Block.
</ResponseField>

<ResponseField name="Error" type="string">
  Contains any error message if an error occurs during subflow execution. Only available when "Use Error Output" is enabled.
</ResponseField>

<ResponseField name="Duration" type="number">
  The time in milliseconds that the subflow took to execute.
</ResponseField>

## Editor Settings

<ParamField path="Flow" type="flow" required>
  Select the flow to execute as a subflow. The flow must exist within the same project.
</ParamField>

<ParamField path="Use Error Output" type="boolean" default={false}>
  When enabled, errors during subflow execution will be sent to the Error output port instead of causing the block to fail. This allows for custom error handling logic.
</ParamField>

<ParamField path="Wait For Input" type="boolean" default={false}>
  When enabled, adds a "Wait For" input port that delays execution until that input is ready.
</ParamField>

<ParamField path="(Dynamic Settings)" type="any">
  For each Input Block in the selected subflow, a corresponding setting appears allowing you to set a default value for that input.
</ParamField>

## Notes

- The block's inputs and outputs are determined by the Input and Output Blocks in the selected subflow
- Errors can either fail the block or be handled via the Error output port
- Subflows can be nested within other subflows for complex workflow organization
- The subflow must be in the same project as the parent flow
- Default values can be set for any input, which will be used if no connection is made to that input port

## Examples

### Example 1: Basic Subflow Usage

1. Create a new flow called "Greeting" with:
   - An Input Block named "name"
   - A Text Block with content "Hello, {inputs.name}!"
   - An Output Block named "message"

2. In your main flow:
   - Add a Subflow Block
   - Select "Greeting" as the Flow
   - Connect a Text Block with a name to the "name" input
   - Use the "message" output as needed

### Example 2: Error Handling

1. Create a subflow that might produce errors
2. In your main flow:
   - Add a Subflow Block
   - Enable "Use Error Output"
   - Connect the Error output to handle potential issues
   - Add error handling logic as needed

## FAQ

<AccordionGroup>
  <Accordion title="Can subflows be nested?">
    Yes, you can use Subflow Blocks within other subflows to create hierarchical workflow structures.
  </Accordion>

  <Accordion title="What happens if an error occurs in the subflow?">
    If "Use Error Output" is enabled, the error message will be sent to the Error output port. Otherwise, the block will fail and stop the flow execution.
  </Accordion>

  <Accordion title="Can I modify the subflow's inputs and outputs?">
    Yes, by modifying the Input and Output Blocks in the subflow. Changes will automatically update the ports on any Subflow Blocks using that flow.
  </Accordion>

  <Accordion title="How can I track how long a subflow takes to execute?">
    The Duration output port provides the execution time in milliseconds for each run of the subflow.
  </Accordion>
</AccordionGroup>

---

---
## advanced/wait-for-event.mdx

---
id: wait-for-event
title: Wait For Event Block
description: Pause flow execution until a specific event is raised, enabling synchronization with external actions or other parts of the flow
sidebarTitle: Wait For Event
---

## Overview

The Wait For Event Block pauses the execution of a flow until a specific event is raised by a [Raise Event Block](/block-reference/advanced/raise-event) or the host project. This block is crucial for scenarios where you need to synchronize your flow with external actions or other parts of the flow.
## Inputs

<ParamField path="Event Name" type="string">
  The name of the event to wait for. This input is only available if `Use Event Name Input` is enabled in the settings. The value will be coerced to a string.
</ParamField>

<ParamField path="Data" type="any">
  Any data to be passed through the block. This data will be outputted from the `Data` output port. Optional.
</ParamField>

## Outputs

<ResponseField name="Data" type="any">
  The data passed in through the `Data` input port, passed through unchanged. If no data was provided to the input, this output will not be available.
</ResponseField>

<ResponseField name="Event Data" type="any">
  The data associated with the event that was raised. The type depends on what data was included when the event was raised. If the event has no associated data, this output will not be available.
</ResponseField>

## Editor Settings

<ParamField path="Event Name" type="string" default="continue">
  The name of the event to wait for. Must match the name of the event raised by the Raise Event Block or the host project. Only used if `Use Event Name Input` is disabled.
</ParamField>

<ParamField path="Use Event Name Input" type="boolean" default={false}>
  If enabled, the Event Name can be provided via the Event Name input port instead of being set in the settings.
</ParamField>

## Examples

### Example: Synchronizing with a Raise Event Block

1. Create a [Raise Event Block](/block-reference/advanced/raise-event) and set the `Event Name` to `myEvent`.
2. Add a Wait For Event Block and set the `Event Name` to `myEvent`.
3. Connect a Text Block with "Raise Event" to the Raise Event Block's Data input.
4. Connect another Text Block with "Waited" to the Wait For Event Block's Data input.
5. Connect both blocks' outputs to separate Text Blocks.
6. Run the flow. The Wait For Event Block will pause until the Raise Event Block raises `myEvent`.
7. Observe how the Wait For Event Block outputs both its input data and the event data.

## Error Handling

The Wait For Event Block does not generate errors under normal circumstances. If the expected event is not raised, the block will wait indefinitely.

## FAQ

<AccordionGroup>
  <Accordion title="Can I use the Wait For Event Block to wait for multiple events?">
    No, each Wait For Event Block can only wait for a single event. To wait for multiple events, use multiple Wait For Event Blocks.
  </Accordion>

  <Accordion title="Can I use the Wait For Event Block with API calls?">
    Yes, you can use an [HTTP Call Block](/block-reference/advanced/http-call) to make an API call, then use the Wait For Event Block to wait for an event raised in response to that call.
  </Accordion>
</AccordionGroup>

## See Also

- [Raise Event Block](/block-reference/advanced/raise-event)
- [HTTP Call Block](/block-reference/advanced/http-call)
- [External Call Block](/block-reference/advanced/external-call)
- [Code Block](/block-reference/advanced/code)

---

---
## advanced/http-call.mdx

---
id: http-call
title: HTTP Call Block
description: Make HTTP requests to external APIs and services
sidebarTitle: HTTP Call
---

## Overview

The HTTP Call Block allows you to make HTTP requests to specified URLs with custom methods, headers, and body. This versatile block is essential for interacting with external APIs or services within your workflow.
## Inputs

<ParamField path="Method" type="string">
  The HTTP method to use for the request (GET, POST, PUT, DELETE). Only shown when "Use Input" is enabled for Method.
</ParamField>

<ParamField path="URL" type="string">
  The URL to make the HTTP request to. Only shown when "Use Input" is enabled for URL.
</ParamField>

<ParamField path="Headers" type="object">
  An object containing the headers to include in the HTTP request. Only shown when "Use Input" is enabled for Headers. Can accept a string containing JSON or an object.
</ParamField>

<ParamField path="Body" type="string">
  The body of the HTTP request. Only shown when "Use Input" is enabled for Body. Can accept a string or an object that will be stringified.
</ParamField>

## Outputs

<ResponseField name="Body" type="string">
  The raw text body of the HTTP response.
</ResponseField>

<ResponseField name="JSON" type="object">
  If the response has a content-type of application/json, this output will contain the parsed JSON object. Otherwise, this output will not be available.
</ResponseField>

<ResponseField name="Status Code" type="number">
  The HTTP status code of the response.
</ResponseField>

<ResponseField name="Headers" type="object">
  An object containing the headers from the HTTP response.
</ResponseField>

## Editor Settings

<ParamField path="Method" type="select" default="GET">
  The HTTP method to use. Options are GET, POST, PUT, or DELETE. Has an "Use Input" toggle to accept the method via input instead.
</ParamField>

<ParamField path="URL" type="string">
  The URL to make the request to. Has a "Use Input" toggle to accept the URL via input instead.
</ParamField>

<ParamField path="Headers" type="code" language="json">
  JSON object containing request headers. Has a "Use Input" toggle to accept headers via input instead.
</ParamField>

<ParamField path="Body" type="code" language="json">
  The request body. Has a "Use Input" toggle to accept body content via input instead.
</ParamField>

<ParamField path="Error on non-200 status code" type="boolean" default={true}>
  If enabled, the block will error if the response status code is not 200.
</ParamField>

## Notes

- When running in a browser environment, requests may be limited by CORS policies. If you encounter CORS issues, try using the Node executor instead.
- Headers provided via input can be either a JSON string or an object
- Body content provided via input can be either a string or an object (which will be stringified)
- The JSON output is only available when the response has a content-type of application/json

## Examples

### Example 1: Make a GET request to an API

1. Create an HTTP Call Block and set the `Method` to `GET` and the `URL` to `https://jsonplaceholder.typicode.com/todos/1`.
2. Run the flow. You should see all of the response data, such as the headers, response code, and body, in the output panel.

### Example 2: Make a POST request to an API

1. Create an HTTP Call Block and set the `Method` to `POST` and the `URL` to `https://jsonplaceholder.typicode.com/posts`. Enable the "Use Input" toggle on the "Body" setting.
2. Create an [Object Block](/block-reference/data/object) with the following content:

---

---
## advanced/code.mdx

---
id: code
title: Code Block
description: Run Python code securely during your flow's execution
sidebarTitle: Code
---

The Code Block allows you to run Python code securely during your flow's execution using Azure Code Interpreter. This block provides a safe and isolated environment for executing custom Python code. Common use cases include:

- Performing complex calculations
- Implementing custom data processing logic
- Using Python libraries and functions
- Data transformation and analysis

<Note>
  The Code Block only supports Python code execution.
</Note>
## Inputs

<ParamField path="input1" type="any" required={false}>
  Default input port. Input names are configurable and each creates a corresponding port. Values are accessible in your Python code via the `inputs` dictionary with typed values (e.g., `inputs["input1"]["type"]`, `inputs["input1"]["value"]`).
</ParamField>

## Outputs 

<ResponseField name="output1" type="any">
  Default output port. Output names are configurable and each creates a corresponding port. The code must return a dictionary with typed values matching the configured output names (e.g., `{"output1": {"type": "string", "value": "result"}}`).
</ResponseField>

## Editor Settings

<ParamField path="Inputs" type="stringList" default={["input1"]}>
  List of input names. Each name creates an input port on the block. Names are sanitized to be valid Python identifiers (only alphanumeric and underscore characters).
</ParamField>

<ParamField path="Outputs" type="stringList" default={["output1"]}>
  List of output names. Each name creates an output port on the block. The code must return values for all configured outputs.
</ParamField>

<ParamField path="AI Assist" type="custom">
  An AI assistant to help write and modify your code.
</ParamField>

<ParamField path="Code" type="code" language="python">
  The Python code to execute. Must include a `main(inputs)` function that processes the inputs and returns a dictionary of outputs. Default template:

  ```python
  def main(inputs):
    return {
      "output1": {
        "type": inputs["input1"]["type"],
        "value": inputs["input1"]["value"]
      }
    }
  ```
</ParamField>

## Code Structure

Your code must:
- Define a `main(inputs)` function
- Access inputs through the `inputs` dictionary where each input has `type` and `value` properties
- Return a dictionary with output names matching those configured in settings
- Each output must have `type` and `value` properties

---

---
## advanced/raise-event.mdx

---
id: raise-event
title: Raise Event Block
description: Trigger events within your flow for host project interaction or flow synchronization
sidebarTitle: Raise Event
---

## Overview

The Raise Event Block allows you to trigger events from within your flow. These events can be listened for by the host project or by a [Wait For Event Block](/block-reference/advanced/wait-for-event) within the same flow. This functionality is useful for:

- Triggering actions in your host application based on the flow's state
- Synchronizing different parts of your flow

The block requires an event name and optionally accepts event data. The event name identifies the event when raised, while the event data can include any additional information you want to associate with the event.
## Inputs

<ParamField path="Event Name" type="string" required>
  The name of the event to raise. This input is only available if `Use Event Name Input` is enabled in the settings. Any non-string inputs will be automatically coerced to strings.
</ParamField>

<ParamField path="Data" type="any">
  The data to associate with the event. Optional. Can be any data type.
</ParamField>

## Outputs

<ResponseField name="Result" type="any">
  Returns the same data that was provided to the Data input. If no data was provided, returns an empty string.
</ResponseField>

## Editor Settings

<ParamField path="Event Name" type="string" default="toast">
  The name of the event to raise. Required if `Use Event Name Input` is disabled. Defaults to "toast".
</ParamField>

<ParamField path="Use Event Name Input" type="boolean" default={false}>
  When enabled, allows the Event Name to be provided via an input port instead of being set in the settings.
</ParamField>

## Block Body Display

The block body will either display:
- The configured event name (when using settings)
- "(Using Input)" (when using the Event Name input port)

## Examples

### Example 1: Using the Toast Event

1. Create a Text Block with the content "Hello, world!".
2. Add a Raise Event Block and set the Event Name to `toast`.
3. Connect the Text Block to the `Data` input of the Raise Event Block.
4. Run the flow. The `Result` output will be "Hello, world!", and a toast message will appear.

### Example 2: Synchronize Flow Parts

1. Create a [Chat Block](/block-reference/ai/chat) with a prompt "What is your name?" using a [Text Block](/block-reference/data/text).
2. Add a Raise Event Block, set the Event Name to `chat`, and connect the Chat Block's `Response` output to the Raise Event Block's `Data` input.
3. In another part of the flow, add a [Wait For Event Block](/block-reference/advanced/wait-for-event) with the Event Name set to `chat`.
4. Run the flow. The Wait For Event Block will pause execution until the Chat Block completes.

## Error Handling

The Raise Event Block will error if:
- The Event Name is not provided when using the Event Name input
- The Event Name setting is empty when not using the input port

## FAQ

<AccordionGroup>
  <Accordion title="Can I pass data with the event?">
    Yes, you can pass data of any type with the event by providing a value to the `Data` input.
  </Accordion>

  <Accordion title="What happens if I raise an event that no one is listening for?">
    If you raise an event with no listeners, it will be raised and immediately discarded without any effect.
  </Accordion>

  <Accordion title="How is raising an event different from an External Call Block?">
    The [External Call Block](/block-reference/advanced/external-call) waits for the external call to complete before continuing, while the Raise Event Block continues immediately after raising the event.
  </Accordion>
</AccordionGroup>

## See Also

- [Wait For Event Block](/block-reference/advanced/wait-for-event)
- [External Call Block](/block-reference/advanced/external-call)
- [Chat Block](/block-reference/ai/chat)
- [Text Block](/block-reference/data/text)

---

---
## advanced/comment.mdx

---
id: comment
title: Comment Block
description: Add notes or comments to your flow for better organization and understanding
sidebarTitle: Comment
---

## Overview

The Comment Block is a special type of block that doesn't perform any operations but serves as a way to add notes or comments to a flow. It can be used to provide additional context or explanation for a group of blocks, making the flow easier to understand. The Comment Block is always rendered behind other blocks and has a distinct appearance with customizable colors.
## Inputs

The Comment Block does not have any inputs.

## Outputs

The Comment Block does not produce any outputs.

## Editor Settings

<ParamField path="Color" type="string" default="rgba(255,255,255,1)">
  The color of the text in the comment block.
</ParamField>

<ParamField path="Background Color" type="string" default="rgba(0,0,0,0.05)">
  The background color of the comment block.
</ParamField>

<ParamField path="Text" type="string" default="">
  The text content of the comment block. Supports Markdown syntax, allowing for rich text formatting including headings, lists, etc.
</ParamField>

## Example Usage

The Comment Block can be used to add notes or comments to a flow. For example, if you have a group of blocks performing a specific operation, you can add a Comment Block behind them to provide a brief explanation of what they do.

Additionally, you can use different colors for the text and background of different Comment Blocks to visually distinguish between different sections of your flow.

## FAQ

<AccordionGroup>
  <Accordion title="Can I use formatting in my comments?">
    Yes, the Comment Block supports Markdown syntax, allowing you to use headings, lists, bold, italic, and other formatting options.
  </Accordion>

  <Accordion title="Do Comment Blocks affect the flow execution?">
    No, Comment Blocks are purely for documentation and organization purposes. They do not affect the execution of your flow in any way.
  </Accordion>
</AccordionGroup>

## See Also

- [Markdown Guide](https://www.markdownguide.org/)
- [Flow Organization Best Practices](/workflow/best-practices)

---

---
## modifiers/to-json.mdx

---
id: to-json
title: To JSON Block
description: Convert any value into a JSON string representation
sidebarTitle: To JSON
---
## Overview
The To JSON Block converts any input value into its JSON string representation. This is useful for serializing data structures, debugging, or preparing data for storage or transmission in a text format.

## Key Features

- Converts any JavaScript value to a JSON string
- Preserves data structure and types
- Handles complex nested objects and arrays
- Useful for data serialization and debugging

## Inputs

<ParamField path="input" type="any" required>
  The value to convert to JSON. Can be any type including objects, arrays, strings, numbers, booleans, or null.
</ParamField>

## Outputs

<ResponseField name="output" type="string">
  The JSON string representation of the input value.
</ResponseField>

## Example: Convert an Object to JSON

1. Create an Object Block with values:
   ```json
   {
     "name": "John Smith",
     "age": 30,
     "hobbies": ["reading", "hiking"]
   }
   ```
2. Add a To JSON Block and connect the Object Block to its `input`.
3. Run the flow. The output will be the stringified JSON:
   ```json
   {"name":"John Smith","age":30,"hobbies":["reading","hiking"]}
   ```

## Error Handling

- Handles circular references by throwing an error
- Non-JSON-serializable values (like functions) will be omitted
- Undefined values will be omitted from objects

## FAQ

<AccordionGroup>
  <Accordion title="What types of values can be converted to JSON?">
    Most JavaScript values can be converted including objects, arrays, strings, numbers, booleans, and null. Functions, undefined values, and circular references cannot be converted to JSON.
  </Accordion>

  <Accordion title="Will the output JSON be formatted/pretty-printed?">
    No, the output JSON will be compact without extra whitespace. To format the JSON, you can use a Code Block with JSON.stringify's space parameter.
  </Accordion>

  <Accordion title="How are special values handled?">
    - undefined values are omitted from objects
    - Functions are omitted from objects
    - Dates are converted to ISO strings
    - NaN and Infinity become null
  </Accordion>
</AccordionGroup>

## See Also

- [Object Block](/block-reference/data/object)
- [Code Block](/block-reference/code/code)

---

---
## modifiers/extract-json.mdx

---
id: extract-json
title: Extract JSON Block
description: Extract JSON data from a string input
sidebarTitle: Extract JSON
---
## Overview
The Extract JSON Block finds and parses the first JSON object or array in the input text. It attempts to locate JSON data between curly braces `{}` or square brackets `[]` and parse it into a JavaScript object.

## Inputs

<ParamField path="input" type="string" required>
  The input string containing JSON data to be extracted. The block will search for the first valid JSON object or array in this string.
</ParamField>

## Outputs

<ResponseField name="output" type="object">
  The extracted and parsed JSON data as a JavaScript object. If no valid JSON is found or parsing fails, this output will be control-flow-excluded.
</ResponseField>

<ResponseField name="noMatch" type="string">
  If no valid JSON could be parsed, this output will contain the original input string. If JSON was successfully parsed, this output will be control-flow-excluded.
</ResponseField>

## Example: Extracting JSON from Text

1. Add an Extract JSON block to your flow
2. Connect a string containing JSON data to the input
3. The block will attempt to find and parse the first JSON object
4. If successful, the parsed object will be available at the `output` port
5. If unsuccessful, the original string will be available at the `noMatch` port

## Error Handling

- If no valid JSON is found or if parsing fails, the `output` port will be control-flow-excluded and the original input string will be available at the `noMatch` port
- If valid JSON is found and parsed successfully, the `noMatch` port will be control-flow-excluded and the parsed object will be available at the `output` port

## FAQ

<AccordionGroup>
  <Accordion title="What types of JSON structures can be extracted?">
    The block can extract both JSON objects (enclosed in curly braces {}) and JSON arrays (enclosed in square brackets []). It will find the first occurrence of either structure in the input string.
  </Accordion>

  <Accordion title="What happens if there are multiple JSON objects in the input?">
    The block will only extract the first valid JSON object or array it finds in the input string. Subsequent JSON objects will be ignored.
  </Accordion>

  <Accordion title="How does the block handle invalid JSON?">
    If the block cannot parse valid JSON from the input string, it will output the original string to the `noMatch` port and control-flow-exclude the `output` port.
  </Accordion>
</AccordionGroup>

## See Also

- [Object Block](/block-reference/data/object)
- [HTTP Call Block](/block-reference/advanced/http-call)

---

---
## modifiers/index.mdx

---
id: index
title: Index Block
description: Retrieve values from an array at specified indices
sidebarTitle: Index
---
## Overview
The Index Block allows you to retrieve values from an array at specified indices. It can return a single value when given a single index or multiple values when provided with an array of indices. This block is particularly useful for extracting specific elements from arrays or for reordering array elements based on a set of indices.

## Key Features

- Retrieve a single value at a specified index
- Extract multiple values using an array of indices
- Supports negative indices for accessing elements from the end of the array
- Option to invert the selection to get all values except those at specified indices

## Inputs

<ParamField path="array" type="any[]" required>
  The input array from which to retrieve values.
</ParamField>

<ParamField path="indicies" type="number | number[]" required>
  The index or array of indices to retrieve. Can be a single number or an array of numbers.
</ParamField>

## Outputs

<ResponseField name="output" type="any | any[]">
  The value(s) retrieved from the input array at the specified index/indices. If a single index is provided or only one value is selected, this will be a single value. If multiple indices are provided, this will be an array of values. If no values are selected, this output will be control-flow-excluded.
</ResponseField>

## Editor Settings

<ParamField path="invert" type="boolean" default={false}>
  When enabled, inverts the selection to return all values except those at the specified indices.
</ParamField>

## Example: Extracting Specific Elements from an Array

1. Create an Array Block with values `[10, 20, 30, 40, 50]`.
2. Add an Index Block and connect the Array Block to its `array` input.
3. Create a Number Block with value `2` (or an Array Block with values `[0, 2, 4]`) and connect it to the Index Block's `indicies` input.
4. Run the flow. The Index Block's `output` will be `30` (or `[10, 30, 50]` if using an array of indices).

## Error Handling

- If an index is out of range (less than 0 or greater than array length), the block will throw an error
- If the array input is not an array, the block will throw an error
- If no values are selected, the output will be control-flow-excluded

## FAQ

<AccordionGroup>
  <Accordion title="Can I use negative indices?">
    Yes, negative indices are supported. They count from the end of the array, so -1 refers to the last element, -2 to the second-to-last, and so on.
  </Accordion>

  <Accordion title="What happens if I provide duplicate indices?">
    If you provide an array of indices with duplicates, the block will return the corresponding values, including duplicates. For example, with input array `[10, 20, 30]` and indices `[0, 1, 1]`, the output will be `[10, 20, 20]`.
  </Accordion>

  <Accordion title="How does the invert option work?">
    When invert is enabled, the block will return all values from the array except those at the specified indices. For example, with input array `[10, 20, 30, 40, 50]` and indices `[1, 3]`, the output with invert enabled would be `[10, 30, 50]`.
  </Accordion>
</AccordionGroup>

## See Also

- [Array Block](/block-reference/data/array)
- [Filter Block](/block-reference/modifiers/filter)
- [Map Block](/block-reference/modifiers/map)

---

---
## modifiers/join.mdx

---
id: join
title: Join Block
description: Concatenate an array of strings into a single string using a specified delimiter
sidebarTitle: Join
---
## Overview
The Join Block concatenates an array of strings into a single string using a specified delimiter. It's useful for formatting lists of items or joining lines of text. The block supports special characters as delimiters and can flatten input arrays before joining.

## Key Features

- Concatenates multiple strings or array elements into a single string
- Supports custom delimiters, including special characters like newline and tab
- Can flatten nested arrays before joining
- Coerces non-string inputs into strings

## Inputs

<ParamField path="input1" type="string | any[]">
  The first string or array to be joined. Additional numbered inputs (input2, input3, etc.) are created dynamically based on connections.
</ParamField>

<ParamField path="joinString" type="string">
  The delimiter used to join the inputs. Only available when "Use Join String Input" is enabled.
</ParamField>

## Outputs

<ResponseField name="output" type="string">
  The resulting joined string.
</ResponseField>

## Editor Settings

<ParamField path="flatten" type="boolean" default={true}>
  When enabled, flattens any array inputs before joining them.
</ParamField>

<ParamField path="joinString" type="string" default="\n">
  The string used as a delimiter to join the inputs. Supports escape characters like \n (newline), \t (tab).
</ParamField>

<ParamField path="useJoinStringInput" type="boolean" default={false}>
  When enabled, allows the join string to be provided via an input port instead of being set in the settings.
</ParamField>

## Example: Join an array of strings with a newline

1. Create an Array Block with values `["apple", "banana", "cherry"]`.
2. Add a Join Block and set the Join String to `\n` in the settings.
3. Connect the Array Block to the Join Block's `input1`.
4. Run the flow. The output should be:
   ```
   apple
   banana
   cherry
   ```

## Error Handling

The Join Block generally doesn't error. If an input is not provided, it outputs an empty string.

## FAQ

<AccordionGroup>
  <Accordion title="Can I use special characters as the Join String?">
    Yes, you can use special characters like newline (`\n`), tab (`\t`), and space (` `) as the Join String. Enter them literally in the Join String field in the settings.
  </Accordion>

  <Accordion title="Can I join an array of non-string values?">
    Yes, you can join an array of any data type. The values will be coerced into strings before joining.
  </Accordion>

  <Accordion title="Can I use a dynamic Join String?">
    Yes, enable the "Use Join String Input" setting to create a new input port for the Join String.
  </Accordion>
</AccordionGroup>

## See Also

- [Split Text Block](/block-reference/modifiers/split-text)
- [Array Block](/block-reference/data/array)
- [Text Block](/block-reference/data/text)
- [Code Block](/block-reference/code/code)

---

---
## modifiers/hash.mdx

---
id: hash
title: Hash Block
description: Calculate MD5 or SHA hash of input data for equivalency comparisons
sidebarTitle: Hash
---
## Overview
The Hash Block calculates the MD5 or SHA hash of incoming data. This block is particularly useful for performing equivalency comparisons, data integrity checks, or generating unique identifiers based on content.

## Key Features

- Support for multiple hash algorithms (MD5, SHA-1, SHA-256, SHA-512)
- Converts input to string before hashing
- Outputs hash value as a string

## Inputs

<ParamField path="input" type="string" required>
  The data to be hashed. Required. Non-string inputs will be coerced to strings.
</ParamField>

## Outputs

<ResponseField name="hash" type="string">
  The calculated hash value of the input data.
</ResponseField>

## Editor Settings

<ParamField path="algorithm" type="string" default="sha256">
  The hash algorithm to use. Options:
  - `md5`: MD5 algorithm
  - `sha1`: SHA-1 algorithm  
  - `sha256`: SHA-256 algorithm
  - `sha512`: SHA-512 algorithm
</ParamField>

## Example: Generating a Hash for Data Comparison

1. Create a Text Block with some sample data, e.g., "Hello, World!".
2. Add a Hash Block and connect the Text Block's output to its `input`.
3. Configure the Hash Block to use SHA-256 algorithm.
4. Run the flow to see the generated hash value.

## Error Handling

- If the input is undefined or null, the block will error
- Invalid algorithm selections will result in an error

## FAQ

<AccordionGroup>
  <Accordion title="Which hash algorithm should I use?">
    The choice of algorithm depends on your specific use case. MD5 is faster but less secure, while SHA-256 and SHA-512 provide stronger security but are slightly slower. For most general purposes, SHA-256 is a good balance of security and performance.
  </Accordion>

  <Accordion title="How are non-string inputs handled?">
    All inputs are coerced to strings before hashing. Numbers, objects, and arrays will be converted to their string representations automatically.
  </Accordion>
</AccordionGroup>

## See Also

- [Compare Block](/block-reference/modifiers/compare)
- [Encrypt Block](/block-reference/modifiers/encrypt)
- [Decrypt Block](/block-reference/modifiers/decrypt)

---

---
## modifiers/extract-markdown-table-blocks.mdx

---
id: extract-markdown-table-blocks
title: Extract Markdown Table Blocks
description: Extract table blocks from markdown-formatted text
sidebarTitle: Extract Markdown Table Blocks
---
## Overview
The Extract Markdown Table Blocks block is designed to parse markdown-formatted text and extract all table blocks within it. This is particularly useful when working with documentation, README files, or any text that contains tables in markdown format.

## Inputs

<ParamField path="input" type="string" required>
  The markdown-formatted text from which to extract table blocks.
</ParamField>

## Outputs

<ResponseField name="firstBlock" type="table">
  The first table block found in the input markdown, converted to a Table value. If no table blocks are found, this output will be control-flow-excluded.
</ResponseField>

<ResponseField name="allBlocks" type="table[]">
  An array of Table values, where each Table represents a table block extracted from the input markdown.
</ResponseField>

## Editor Settings

<ParamField path="coerceToTable" type="boolean" default={false}>
  When enabled, attempts to coerce the extracted content into table format. This can help handle some malformed markdown tables.
</ParamField>

## Example: Extracting Tables from Documentation

1. Create a new flow and add an Extract Markdown Table Blocks block.
2. Add a Text block with markdown content containing table blocks and connect it to the `input` of the Extract Markdown Table Blocks block.
3. Connect any of the outputs to view the extracted tables or header information.
4. Run the flow to see the results.

## Error Handling

- If no table blocks are found in the input markdown, the `firstBlock` output will be control-flow-excluded and `allBlocks` will be an empty array.
- The block will not throw an error for invalid markdown; it will attempt to extract any table blocks it can identify.

## FAQ

<AccordionGroup>
  <Accordion title="What format are the tables expected to be in?">
    The block expects tables to be formatted using standard markdown table syntax with pipe characters (|) separating columns and hyphens (-) in the separator row.
  </Accordion>

  <Accordion title="How are table headers handled?">
    Table headers are identified by the separator row (containing hyphens) that follows the header row. The headers are preserved in the output Table values.
  </Accordion>

  <Accordion title="Does this block handle complex table formatting?">
    Yes, the block handles standard markdown table formatting including text alignment indicators (:---:) and varying column widths. However, nested tables or HTML tables are not supported.
  </Accordion>
</AccordionGroup>

## See Also

- [Extract Markdown Code Blocks](/block-reference/modifiers/extract-markdown-code-blocks)
- [Extract JSON Block](/block-reference/modifiers/extract-json)
- [Text Block](/block-reference/data/text)

---

---
## modifiers/extract-yaml.mdx

---
id: extract-yaml
title: Extract YAML Block
description: Extract YAML data from strings and convert to JavaScript objects
sidebarTitle: Extract YAML
---
## Overview
The Extract YAML Block is designed to parse YAML content from input strings and convert it into JavaScript objects. This block is particularly useful when working with configuration files, data serialization, or any scenario where YAML-formatted data needs to be extracted and processed.

## Key Features

- Extract YAML data from input strings with a specified root property name
- Convert YAML to JavaScript objects
- Optional JSONPath querying of extracted YAML
- Configurable error handling for invalid YAML

## Inputs

<ParamField path="input" type="string" required>
  The string containing YAML data to be extracted.
</ParamField>

<ParamField path="rootPropertyName" type="string">
  The name of the root YAML property to extract. Only available when "Use Root Property Name Input" is enabled in settings.
</ParamField>

<ParamField path="objectPath" type="string">
  A JSONPath query to extract specific data from the YAML object. Only available when "Use Object Path Input" is enabled in settings.
</ParamField>

## Outputs

<ResponseField name="output" type="object | any">
  The extracted and parsed YAML data. If using an Object Path, this will be the first matching value. If no valid YAML is found or no matches are found, this output will be control-flow-excluded.
</ResponseField>

<ResponseField name="matches" type="any[]">
  When using an Object Path, this contains all values that match the path query. Only available when an Object Path is specified.
</ResponseField>

<ResponseField name="noMatch" type="string">
  The raw YAML text that was attempted to be parsed, only output when parsing fails or no matches are found.
</ResponseField>

## Editor Settings

<ParamField path="rootPropertyName" type="string" default="yamlDocument">
  The name of the root YAML property to extract. The input text must have this property name followed by a colon somewhere in it.
</ParamField>

<ParamField path="useRootPropertyNameInput" type="boolean" default={false}>
  When enabled, allows the root property name to be provided via an input port instead of being set in the settings.
</ParamField>

<ParamField path="objectPath" type="string">
  A JSONPath query to extract specific data from the YAML object. Uses JSONPath syntax.
</ParamField>

<ParamField path="useObjectPathInput" type="boolean" default={false}>
  When enabled, allows the object path to be provided via an input port instead of being set in the settings.
</ParamField>

## Example: Extracting YAML from a Configuration File

1. Create a new flow and add a Text Block with YAML content that includes a root property name (e.g., `yamlDocument:`).
2. Add an Extract YAML Block and connect the Text Block's output to its `input`.
3. Configure the root property name and optional object path in the settings.
4. Connect the outputs to view the extracted and parsed YAML data.
5. Run the flow to see the results.

## Error Handling

- If no valid YAML is found under the specified root property name, the `output` will be control-flow-excluded and `noMatch` will contain the raw text.
- If an object path is specified but no matches are found, the `output` will be control-flow-excluded.
- If the YAML parsing fails, the `output` will be control-flow-excluded and `noMatch` will contain the attempted YAML text.

## FAQ

<AccordionGroup>
  <Accordion title="What is the root property name used for?">
    The root property name (default: "yamlDocument") is used to locate the YAML content within the input text. The block looks for this property name followed by a colon, and considers all indented text after it as part of the YAML to parse.
  </Accordion>

  <Accordion title="How does the Object Path feature work?">
    The Object Path uses JSONPath syntax to query the parsed YAML object. When specified, it allows you to extract specific values from the YAML structure. The first match is provided in the `output`, while all matches are available in the `matches` output.
  </Accordion>
</AccordionGroup>

## See Also

- [Extract JSON Block](/block-reference/modifiers/extract-json)
- [Extract Object Path Block](/block-reference/modifiers/extract-object-path)
- [Text Block](/block-reference/data/text)

---

---
## modifiers/flatten.mdx

---
id: flatten
title: Flatten Block
description: Flatten nested arrays into a single-level array
sidebarTitle: Flatten
---
## Overview
The Flatten Block is designed to simplify complex nested array structures by flattening them into a single-level array. This block is particularly useful when dealing with multi-dimensional arrays or when you need to process all elements of a nested structure in a linear fashion.

## Key Features

- Flattens nested arrays one level deep
- Preserves the order of elements from the original nested structure
- Handles arrays containing both nested arrays and non-array elements

## Inputs

<ParamField path="input" type="any[][]" required>
  The nested array structure to be flattened. Must be a nested array (array of arrays). Non-nested arrays or other types will result in an error.
</ParamField>

## Outputs

<ResponseField name="output" type="any[]">
  The resulting flattened array containing all elements from the input, with one level of nesting removed.
</ResponseField>

## Example: Flattening a Nested Array

1. Create an Array Block with a nested array structure, e.g., `[[1, 2], [3, 4], [5, 6]]`.
2. Add a Flatten Block and connect the Array Block to its `input`.
3. Run the flow. The Flatten Block's `output` will be `[1, 2, 3, 4, 5, 6]`.

## Error Handling

- If no input is provided, the block will error with "Input is required"
- If the input is not a nested array (array of arrays), the block will error with "Input is not a nested array"
- The block will only flatten one level deep - for deeper nesting, multiple Flatten blocks can be chained

## FAQ

<AccordionGroup>
  <Accordion title="Does the Flatten Block work with objects?">
    No, the Flatten Block is designed to work only with nested arrays. It will error if given objects or other non-array inputs.
  </Accordion>

  <Accordion title="How deep does the flattening go?">
    The Flatten Block only flattens one level deep. For example, `[[1, [2, 3]], [4, 5]]` becomes `[1, [2, 3], 4, 5]`. To flatten deeper levels, chain multiple Flatten blocks together.
  </Accordion>
</AccordionGroup>

## See Also

- [Array Block](/block-reference/data/array)
- [Map Block](/block-reference/modifiers/map)
- [Filter Block](/block-reference/modifiers/filter)

---

---
## modifiers/extract-object-path.mdx

---
id: extract-object-path
title: Extract Object Path Block
description: Extract data from objects or arrays using JSONPath queries
sidebarTitle: Extract Object Path
---
## Overview
The Extract Object Path Block allows you to run [JSONPath](https://www.npmjs.com/package/jsonpath-plus) queries on objects or arrays. This block is particularly useful for extracting specific data from complex JSON structures, such as API responses or nested objects.

## Key Features

- Extract data using JSONPath queries
- Support for objects, arrays, and other JavaScript values with properties
- Ability to perform complex queries and filtering
- Dynamic path construction using input ports

## Inputs

<ParamField path="object" type="object | any[] | string" required>
  The object, array, or string to query using the JSONPath.
</ParamField>

<ParamField path="path" type="string" required>
  The JSONPath query to use for extracting properties from the input object. Only available when "Use Path Input" is enabled in settings.
</ParamField>

## Outputs

<ResponseField name="match" type="any">
  The first value that matches the specified path. If no match is found, this output will be control-flow-excluded.
</ResponseField>

<ResponseField name="all_matches" type="any[]">
  An array of all values that match the specified path. If no matches are found, this output will run with an empty array.
</ResponseField>

## Editor Settings

<ParamField path="path" type="string" default="$">
  The JSONPath query to use for extracting properties from the input object. Uses JSONPath syntax.
</ParamField>

<ParamField path="usePathInput" type="boolean" default={false}>
  When enabled, allows the path to be provided via an input port instead of being set in the settings.
</ParamField>

## Example: Extract a property from an object

1. Create an Object Block with the following JSON:
   ```json
   {
     "name": "John Doe",
     "age": 30
   }
   ```
2. Add an Extract Object Path Block and connect the Object Block to it.
3. Set the `Path` of the Extract Object Path Block to `$.name`.
4. Run the flow. The Extract Object Path Block should output `John Doe`.

## Error Handling

- If the path is invalid or not provided, the block will throw an error
- If the path is valid but no value is found, the `match` output will be control-flow-excluded and the `all_matches` output will run with an empty array
- If the input object is undefined or null, it will be treated as null for the JSONPath query

## FAQ

<AccordionGroup>
  <Accordion title="Can I use this block with non-object data types?">
    Yes, the Extract Object Path Block can work with arrays and other JavaScript values that have properties, such as strings. For example, you can use `$.length` to get the length of a string.
  </Accordion>

  <Accordion title="How can I extract data from an API response?">
    You can use the HTTP Call Block to make an API request, and then use the Extract Object Path Block to extract specific data from the response.
  </Accordion>
</AccordionGroup>

## See Also

- [Code Block](/block-reference/code)
- [Object Block](/block-reference/data/object)
- [Array Block](/block-reference/data/array)
- [Extract with Regex Block](/block-reference/modifiers/extract-with-regex)
- [Data Types](/docs/workflow/data-types)

---

---
## modifiers/extract-with-regex.mdx

---
id: extract-with-regex
title: Extract with Regex Block
description: Extract strings from input using regular expressions
sidebarTitle: Extract Regex
---
## Overview
The Extract With Regex Block allows you to extract one or more strings from an input string using a regular expression. It's useful for parsing responses from Language Models (LLMs), extracting specific values from files, or any scenario where you need to match patterns in text.

## Key Features

- Extract multiple strings using capture groups
- Configurable error handling for failed matches
- Support for multiline mode
- Flexible output options including all matches and success/failure flags

## Inputs

<ParamField path="input" type="string" required>
  The string to match the regex against. Non-string inputs will be coerced to strings.
</ParamField>

<ParamField path="regex" type="string">
  The regular expression to use for matching. Only available when "Use Regex Input" is enabled in settings.
</ParamField>

## Outputs

<ResponseField name="output1, output2, etc" type="string">
  One output port per capture group in the regex, containing the matched content for that capture group.
</ResponseField>

<ResponseField name="matches" type="string[]">
  An array of all matched strings from the first capture group.
</ResponseField>

<ResponseField name="succeeded" type="boolean">
  True if the regex matched the input string, false otherwise.
</ResponseField>

<ResponseField name="failed" type="boolean">
  True if the regex did not match the input string, false otherwise.
</ResponseField>

## Editor Settings

<ParamField path="errorOnFailed" type="boolean" default={false}>
  If enabled, the block will error if the regex doesn't match the input string.
</ParamField>

<ParamField path="multilineMode" type="boolean" default={false}>
  Enables multiline mode for the regex, affecting `^` and `$` behavior.
</ParamField>

<ParamField path="regex" type="string" default="([a-zA-Z]+)">
  The regular expression to use for matching.
</ParamField>

<ParamField path="useRegexInput" type="boolean" default={false}>
  When enabled, allows the regex to be provided via an input port instead of being set in the settings.
</ParamField>

## Example: Extract a command from an LLM response

1. Create a Chat Block with a System Prompt:
   ```
   Your reply can initiate commands, for example `!hello` will cause "Hello world" to appear for the user. Try it out now!
   ```
2. Add an Extract With Regex Block and connect the Chat Block's output to its input.
3. Set the Regex to `!([a-zA-Z]+)`.
4. Connect the `Output 1` port to a Text Block to display the matched command.## Error Handling

- The block will error if the input string is not provided or if the regex is invalid.
- If "Error on failed" is enabled, the block will error when the regex doesn't match the input.

## FAQ

<AccordionGroup>
  <Accordion title="How do I match a string that contains a special character?">
    For special characters like newlines, you can include them literally in the regex editor. They will be preserved in the regular expression.
  </Accordion>
</AccordionGroup>

## See Also

- [Extract Object Path Block](/block-reference/modifiers/extract-object-path)
- [Match Block](/block-reference/modifiers/match)

---

---
## modifiers/pop.mdx

---
id: pop
title: Pop Block
description: Remove and return the first or last element from an array
sidebarTitle: Pop
---
## Overview
The Pop Block removes either the first or last element from an array and outputs both the removed element and the remaining array. By default, it pops the last element. This block is useful for processing array elements one by one in a loop.

## Key Features

- Removes and returns the first or last element of an array
- Outputs both the popped element and the remaining array
- Configurable to pop from the front or back of the array
- Useful for iterative array processing

## Inputs

<ParamField path="array" type="any[]" required>
  The array to pop from. Required. Non-array inputs will not be coerced.
</ParamField>

## Outputs

<ResponseField name="lastItem" type="any">
  The popped element. Will be labeled as "First" if popping from front, "Last" if popping from back.
</ResponseField>

<ResponseField name="restOfArray" type="any[]">
  The remaining elements of the array after popping.
</ResponseField>

## Editor Settings

<ParamField path="fromFront" type="boolean" default={false}>
  If enabled, the first element of the array will be popped instead of the last.
</ParamField>

## Example: Pop the last element from an array

1. Create an Array Block with values `["John", "Doe", "30", "Engineer"]`.
2. Add a Pop Block and connect the Array Block to its `array` input.
3. Run the flow. The `Last` output should be `"Engineer"` and the `Rest` output should be `["John", "Doe", "30"]`.

## Example: Pop the first element from an array

1. Create an Array Block with values `["John", "Doe", "30", "Engineer"]`.
2. Add a Pop Block, enable the `Pop from front` setting, and connect the Array Block to its `array` input.
3. Run the flow. The `First` output should be `"John"` and the `Rest` output should be `["Doe", "30", "Engineer"]`.

## Error Handling

The Pop Block will error if:
- The `array` input is not provided
- The input is not an array
- The input array is empty

## FAQ

<AccordionGroup>
  <Accordion title="Can I pop multiple elements from an array at once?">
    No, the Pop Block can only pop one element at a time. To remove multiple elements, use multiple Pop Blocks in sequence.
  </Accordion>

  <Accordion title="Can I use the Pop Block to pop elements from a string?">
    No, the Pop Block only works with arrays. For string manipulation, consider using a Code Block with custom JavaScript.
  </Accordion>

  <Accordion title="What if the array is empty?">
    The Pop Block will error if the array is empty. Use an If Block to check if the array is empty before popping from it.
  </Accordion>
</AccordionGroup>

## See Also

- [Array Block](/block-reference/data/array)
- [Slice Block](/block-reference/modifiers/slice)
- [Code Block](/block-reference/code/code)
- [Loop Controller Block](/block-reference/logic/loop-controller)

---

---
## modifiers/chunk.mdx

---
id: chunk
title: Chunk Block
description: Split a string into an array of strings based on token count
sidebarTitle: Chunk
---
## Overview
The Chunk Block is used to split a string into an array of strings based on a token count. This is particularly useful for handling large text inputs that exceed token limits in Language Models (LLMs), or for truncating strings to specific token counts.

## Inputs

<ParamField path="input" type="string" required>
  The string to be split into chunks. Non-string inputs will be coerced to strings.
</ParamField>

<ParamField path="model" type="string">
  The AI model to use for tokenization. Only available when "Use Model Input" is enabled in settings.
</ParamField>

## Outputs

<ResponseField name="chunks" type="string[]">
  An array containing all the chunks after splitting the input string.
</ResponseField>

<ResponseField name="first" type="string">
  The first chunk from the chunks array. Useful for truncating text from the start.
</ResponseField>

<ResponseField name="last" type="string">
  The last chunk from the chunks array. Useful for truncating text from the end.
</ResponseField>

<ResponseField name="indexes" type="number[]">
  A list of sequential numbers starting from 1, one for each chunk. Useful for filtering or zipping with the chunks array.
</ResponseField>

<ResponseField name="count" type="number">
  The total number of chunks created.
</ResponseField>

## Editor Settings

<ParamField path="AI Model" type="string" default="gpt-3.5-turbo">
  The model to use for tokenizing the text. Different models may tokenize text differently. Can be overridden by the "model" input if "Use Model Input" is enabled.
</ParamField>

<ParamField path="Use Model Input" type="boolean" default={false}>
  When enabled, adds a "model" input port that can override the "AI Model" setting.
</ParamField>

<ParamField path="Number of tokens per chunk" type="number" default={1024} min={1} max={32768}>
  The target number of tokens for each chunk. The actual chunk sizes may vary slightly to maintain text coherence.
</ParamField>

<ParamField path="Overlap (in %)" type="number" default={0} min={0} max={100}>
  The percentage of overlap between consecutive chunks. For example, with a 50% overlap and 1000 tokens per chunk, each chunk will share approximately 500 tokens with the next chunk. This helps maintain context between chunks.
</ParamField>

## Example: Chunking a Long Text

1. Create a Text Block with a long piece of text.
2. Add a Chunk Block and connect the Text Block to its input.
3. Configure the desired token count and overlap in the settings.
4. Run the flow. The text will be split into chunks based on your settings.

## Error Handling

The Chunk Block will automatically coerce non-string inputs into strings. No other notable error handling behavior.

## FAQ

<AccordionGroup>
  <Accordion title="Why use chunking for LLMs?">
    Chunking is useful to avoid hitting token count limits in LLMs. You can split a long string into multiple chunks, process each chunk separately, and then combine the results.
  </Accordion>

  <Accordion title="How does the overlap feature work?">
    The overlap percentage determines how much text is shared between consecutive chunks. For example, with 1000 tokens per chunk and 50% overlap, each chunk will share approximately 500 tokens with the next chunk. This helps maintain context and coherence between chunks.
  </Accordion>
</AccordionGroup>

## See Also

- [Batching](/user-guide/workflow/batching)
- [Chat Block](/block-reference/ai/chat)
- [Text Block](/block-reference/data/text)

---

---
## modifiers/filter.mdx

---
id: filter
title: Filter Block
description: Filter an array based on boolean conditions
sidebarTitle: Filter
---
## Overview
The Filter Block allows you to filter an array based on a corresponding array of boolean values. It takes an array of any data type and an array of boolean values of the same length, then outputs a new array containing only the elements where the corresponding boolean value is `true`.

This block is particularly useful for filtering arrays based on specific conditions, especially when combined with other blocks like [Compare](/block-reference/modifiers/compare) in a batched operation.

## Inputs

<ParamField path="array" type="any[]" required>
  The array to be filtered. Non-array inputs will be coerced into an array.
</ParamField>

<ParamField path="include" type="boolean[]" required>
  An array of boolean values indicating whether to include each element in the array. The length of this array should match the length of the array input.
</ParamField>

## Outputs

<ResponseField name="filtered" type="any[]">
  The filtered array, containing only the elements where the corresponding boolean value in the include input was `true`. The output maintains the data type of the input array.
</ResponseField>

## Example: Filter numbers greater than 3

1. Create an Array Block with values `[1, 2, 3, 4, 5]`.
2. Add a Compare Block, set comparison to `>`, and enable batching.
3. Create a Number Block with value `3`.
4. Connect the Array Block to Compare Block's `A` input, and Number Block to `B` input.
5. Add a Filter Block, connect Array Block to `array` input and Compare Block's `Result` to `include` input.
6. Run the flow. The Filter Block's `filtered` output should be `[4, 5]`.

## Error Handling

The Filter Block will error if:
- The `array` or `include` inputs are not provided
- The lengths of the input arrays do not match

## FAQ

<AccordionGroup>
  <Accordion title="What happens if the lengths of the array and include inputs do not match?">
    The Filter Block will error. The lengths of the array and include inputs should always match.
  </Accordion>

  <Accordion title="Can I use the Filter Block to filter an array of objects?">
    Yes, you can use the Filter Block to filter an array of any data type, including objects. Just make sure to provide an array of boolean values indicating whether to include each object in the filtered array.
  </Accordion>
</AccordionGroup>

## See Also

- [Array Block](/block-reference/data/array)
- [Compare Block](/block-reference/modifiers/compare)
- [Number Block](/block-reference/data/number)
- [Extract Object Path Block](/block-reference/modifiers/extract-object-path)
- [Evaluate Block](/block-reference/modifiers/evaluate)
- [Coalesce Block](/block-reference/modifiers/coalesce)
- [Join Block](/block-reference/modifiers/join)

---

---
## modifiers/extract-markdown-code-blocks.mdx

---
id: extract-markdown-code-blocks
title: Extract Markdown Code Blocks
description: Extract code blocks from markdown-formatted text
sidebarTitle: Extract Markdown Code Blocks
---
## Overview
The Extract Markdown Code Blocks block is designed to parse markdown-formatted text and extract all code blocks within it. This is particularly useful when working with documentation, README files, or any text that contains code snippets in markdown format.

## Inputs

<ParamField path="input" type="string" required>
  The markdown-formatted text from which to extract code blocks.
</ParamField>

## Outputs

<ResponseField name="firstBlock" type="string">
  The first code block found in the input markdown. If no code blocks are found, this output will be control-flow-excluded.
</ResponseField>

<ResponseField name="allBlocks" type="string[]">
  An array of strings, where each string represents a code block extracted from the input markdown.
</ResponseField>

<ResponseField name="languages" type="string[]">
  An array of strings containing the language identifiers specified for each code block. For example, in "```python", "python" would be the language identifier.
</ResponseField>

## Example: Extracting Code from a README

1. Create a new flow and add an Extract Markdown Code Blocks block.
2. Add a Text block with markdown content containing code blocks and connect it to the `input` of the Extract Markdown Code Blocks block.
3. Connect any of the outputs to view the extracted code blocks or language information.
4. Run the flow to see the results.

## Error Handling

- If no code blocks are found in the input markdown, the `firstBlock` output will be control-flow-excluded and `allBlocks` will be an empty array.
- The block will not throw an error for invalid markdown; it will attempt to extract any code blocks it can identify.

## FAQ

<AccordionGroup>
  <Accordion title="What format are the code blocks expected to be in?">
    The block expects code blocks to be formatted using triple backticks (```) as per standard markdown syntax. Both fenced code blocks with optional language identifiers are supported.
  </Accordion>

  <Accordion title="How are language identifiers handled?">
    Language identifiers are extracted from the opening fence of code blocks (e.g., ```python). If no language is specified, an empty string is used in the languages array.
  </Accordion>

  <Accordion title="Does this block handle inline code?">
    No, this block is designed to extract full code blocks, not inline code snippets that are typically wrapped in single backticks.
  </Accordion>
</AccordionGroup>

## See Also

- [Extract JSON Block](/block-reference/modifiers/extract-json)
- [Chunk Block](/block-reference/modifiers/chunk)
- [Text Block](/block-reference/data/text)

---

---
## modifiers/shuffle.mdx

---
id: shuffle
title: Shuffle Block
description: Randomize the order of elements in an array
sidebarTitle: Shuffle
---
## Overview
The Shuffle Block randomizes the order of elements in an array. It's like shuffling a deck of cards - you give it a list of items, and it mixes them up into a random order. This is useful when you want to randomize a playlist, create random selections, or add variety to any ordered list.

## Key Features

- Randomly reorders any list of items
- Creates a new shuffled list (keeps your original list unchanged)
- Works with any type of items (numbers, text, objects, etc.)
- Automatically handles single items by treating them as a one-item list

## Inputs

<ParamField path="array" type="any[]" required>
  The list of items you want to shuffle. If you input a single item instead of a list, it will be treated as a one-item list.
</ParamField>

## Outputs

<ResponseField name="shuffled" type="any[]">
  A new list containing all your input items in a random order.
</ResponseField>

## Example: Shuffle a List of Numbers

1. Create an Array Block with numbers `[1, 2, 3, 4, 5]`
2. Add a Shuffle Block and connect the Array Block to its `array` input
3. Run the flow. The Shuffle Block's `shuffled` output will contain the same numbers in a random order, like `[3, 1, 5, 2, 4]`

## Error Handling

- If nothing is connected to the input, the block will output an empty list
- If you input a single item instead of a list, it will work fine - it just treats it as a one-item list

## FAQ

<AccordionGroup>
  <Accordion title="Can I shuffle a list of anything, not just numbers?">
    Yes! You can shuffle lists of any type of items - text, numbers, objects, or even mixed content.
  </Accordion>

  <Accordion title="Does shuffling change my original list?">
    No, your original list stays exactly the same. The Shuffle Block creates a new list with the items in a random order.
  </Accordion>

  <Accordion title="How random is the shuffle?">
    The shuffle is random enough for most everyday purposes (like shuffling songs or cards), but shouldn't be used for security or gambling purposes where you need true randomness.
  </Accordion>
</AccordionGroup>

## See Also

- [Array Block](/block-reference/data/array)
- [Filter Block](/block-reference/modifiers/filter)
- [Join Block](/block-reference/modifiers/join)
- [Code Block](/block-reference/modifiers/code)
- [RNG Block](/block-reference/modifiers/rng)

---

---
## modifiers/slice.mdx

---
id: slice
title: Slice Block
description: Extract a portion of an array based on specified start index and count
sidebarTitle: Slice
---
## Overview
The Slice Block extracts a portion of an array. It takes an array as input and outputs a new array that starts at a specified index and contains a specified number of elements. This block is useful for manipulating arrays, such as extracting a subset of data from a larger dataset.

## Key Features

- Extract a subset of elements from an array
- Configurable start index and count
- Option to provide start and count values via input ports
- Handles empty/undefined inputs gracefully

## Inputs

<ParamField path="input" type="any[]" required>
  The array to be sliced.
</ParamField>

<ParamField path="start" type="number">
  The index at which to start the slice. Only available when "Use Start Input" is enabled.
</ParamField>

<ParamField path="count" type="number">
  The number of elements to include in the slice. Only available when "Use Count Input" is enabled.
</ParamField>

## Outputs

<ResponseField name="output" type="any[]">
  The sliced array containing the extracted elements from the input array.
</ResponseField>

## Editor Settings

<ParamField path="start" type="number" default={0}>
  The index at which to start the slice. If not provided, defaults to 0.
</ParamField>

<ParamField path="count" type="number">
  The number of elements to include in the slice. If not provided, includes all elements from start to end.
</ParamField>

<ParamField path="useStartInput" type="boolean" default={false}>
  When enabled, allows the start index to be provided via an input port instead of being set in the settings.
</ParamField>

<ParamField path="useCountInput" type="boolean" default={false}>
  When enabled, allows the count to be provided via an input port instead of being set in the settings.
</ParamField>

## Example: Slice an array

1. Create an Array Block with values `[1, 2, 3, 4, 5]`.
2. Add a Slice Block and set the `Start` to `2` and the `Count` to `2`.
3. Connect the Array Block to the Slice Block's `input`.
4. Run the flow. The Slice Block's `output` should be `[3, 4]`.

## Error Handling

- The block will error if the `input` is not provided or is not an array
- If start or count inputs are enabled but not connected, the block will use the default values
- Using a negative count will result in an error

## FAQ

<AccordionGroup>
  <Accordion title="What happens if the Start is greater than the length of the array?">
    The Slice Block will return an empty array.
  </Accordion>

  <Accordion title="What happens if the Count is greater than the number of elements in the array?">
    The Slice Block will return all elements from the Start to the end of the array.
  </Accordion>

  <Accordion title="Can I use negative numbers for the Start and Count?">
    You can use negative numbers for the Start to count from the end of the array. However, using a negative number for the Count will result in an error.
  </Accordion>
</AccordionGroup>

## See Also

- [Array Block](/block-reference/data/array)
- [Extract Object Path Block](/block-reference/modifiers/extract-object-path)
- [Code Block](/block-reference/code/code)
- [Split Text Block](/block-reference/modifiers/split-text)
- [Join Block](/block-reference/modifiers/join)

---

---
## io/user-input.mdx

---
id: user-input
title: User Input Block
description: Prompt users for input during flow execution, enabling interactive workflows
sidebarTitle: User Input
---

## Overview
The User Input Block allows you to prompt users for input during flow execution. This block is essential for creating interactive workflows where user input is required to proceed. It can use either static prompts defined in the block settings or dynamic prompts provided via the block's input.

## Inputs

<ParamField path="questions" type="string[]" optional>
  An array of questions to prompt the user. Only available when "Use Input" is enabled.
</ParamField>

<ParamField path="wait" type="any" optional>
  A value to wait for before showing the input prompt. Only available when "Wait For Input" is enabled.
</ParamField>

## Outputs

<ResponseField name="output" type="string[]">
  An array containing just the user's answers to the prompted questions.
</ResponseField>

<ResponseField name="questions" type="string[]">
  An array containing just the questions that were asked.
</ResponseField>

<ResponseField name="questionsAndAnswers" type="string[]">
  An array containing the questions and answers formatted as "Question\nAnswer".
</ResponseField>

## Editor Settings

<ParamField path="prompt" type="string" default="This is an example question?">
  The message to display to the user when prompting for input. Only editable when "Use Input" is disabled.
</ParamField>

<ParamField path="useInput" type="boolean" default={false}>
  When enabled, allows the prompt message to be provided via the questions input port instead of the editor settings.
</ParamField>

<ParamField path="useWaitForInput" type="boolean" default={false}>
  When enabled, delays showing the input prompt until the "Wait For" input receives a value.
</ParamField>

<ParamField path="renderingFormat" type="string" default="markdown">
  The format to render the prompt in. Options:
  - markdown: Renders the prompt as markdown
  - preformatted: Renders the prompt as preformatted text
</ParamField>

## Examples

### Static Prompt

1. Add a User Input Block to your flow.
2. Set the "Prompt" to "What is your name?" in the block settings.
3. Run the flow. It will pause and prompt the user for input.
4. After the user submits their name, the flow continues with the input as the block's output.

### Dynamic Prompts

1. Add a User Input Block and enable the "Use Input" toggle.
2. Create an Array Block with two Text Blocks: "What is your name?" and "What is your favorite color?"
3. Connect the Array Block to the User Input Block's "Questions" input.
4. Run the flow. It will prompt the user with both questions sequentially.
5. The block's output will be an array containing the user's answers.

## Error Handling

The User Input Block does not typically produce errors as it simply waits for user input. However, if there are issues with the user interface or the block fails to receive a response, it may timeout and return an error.

<Warning>
  The User Input Block does not support input masking. Avoid using it for sensitive information like passwords.
</Warning>

## FAQ

<AccordionGroup>
  <Accordion title="Can I prompt for multiple inputs at once?">
    Yes, you can use an Array Block connected to the "Questions" input to prompt for multiple inputs sequentially.
  </Accordion>

  <Accordion title="What happens if the user doesn't provide input?">
    If the user submits without providing input, the block will output an empty string for that prompt.
  </Accordion>

  <Accordion title="How does the Wait For Input feature work?">
    When "Wait For Input" is enabled, the input prompt won't be shown until a value is received on the "Wait For" input port. This allows you to sequence prompts after other operations complete.
  </Accordion>

  <Accordion title="What's the difference between the output formats?">
    - "Answers Only" gives you just the user responses
    - "Questions Only" gives you just the questions asked
    - "Q & A" combines each question and answer pair with a newline between them
  </Accordion>
</AccordionGroup>

## See Also

- [Array Block](/block-reference/data/array)
- [Text Block](/block-reference/data/text)
- [Split Block](/block-reference/text/split-text)
- [Join Block](/block-reference/text/join)

---

---
## io/input.mdx

---
id: input
title: Flow Input Block
description: Define inputs for your flow, enabling reusable and dynamic workflows
sidebarTitle: Input
---
## Overview
The Flow Input Block is a crucial component for creating dynamic and reusable flows. It allows you to define inputs that can be passed into your flow when it's called via the SDK or used as a subflow. This flexibility enables you to create versatile workflows that can adapt to different scenarios based on the input provided.

## Inputs

<ParamField path="default" type="any" optional>
  The default value for the input if no value is provided when the flow is called. Only available if the `Use Default Value Input` setting is enabled.
</ParamField>

## Outputs

<ResponseField name="data" type="any">
  The value of the input. This will be the value provided when the flow is called, or the default value if no value is provided. The data type matches the type specified in the Editor Settings.
</ResponseField>

## Editor Settings

<ParamField path="id" type="string" required>
  The unique identifier for the input. This ID is used when calling the flow and defines the input's name in the UI.
</ParamField>

<ParamField path="dataType" type="string" default="string">
  Specifies the expected data type for the input.
</ParamField>

<ParamField path="defaultValue" type="any" optional>
  The default value used when no input is provided during flow execution.
</ParamField>

<ParamField path="useDefaultValueInput" type="boolean" default={false}>
  When enabled, allows the default value to be provided via an input port.
</ParamField>

<ParamField path="editor" type="string" default="auto">
  The editor to use when editing this value in the UI. Make sure this matches the data type.
  Options:
  - none: No editor
  - auto: Automatically select editor based on data type
  - string: String editor
  - number: Number editor
  - code: Code editor
  - dataTypeSelector: Data type selector
  - stringList: String list editor
  - keyValuePair: Key-value pair editor
  - toggle: Toggle switch editor
</ParamField>

## Examples

### Basic Input Definition

1. Add a Flow Input Block to your flow
2. Set the ID to `username` and the Data Type to `string`
3. Set a Default Value of `"Guest"`

Now, your flow has an input named `username` that defaults to "Guest" if no value is provided.

### Using Flow Input in a Subflow

1. Create a new flow with a Flow Input Block
2. Set the ID to `temperature` and the Data Type to `number`
3. Add a Conditional Block that checks if the temperature is above 30°C
4. Save this flow and return to your main flow
5. Add a Subflow Block and select the flow you just created
6. The Subflow Block will now have an input port for `temperature`

This example creates a reusable subflow that can perform actions based on a temperature input.

## Error Handling

The Flow Input Block will throw an error if:
- The provided input value cannot be coerced into the specified data type
- A required input is not provided and has no default value
- For array data types, undefined inputs will be converted to empty arrays

<Warning>
  Always ensure that your input values match the expected data types to avoid runtime errors.
</Warning>

## Best Practices

- Use descriptive IDs for your inputs to make your flows more readable
- Set appropriate default values to handle cases where inputs aren't provided
- Consider using the `Use Default Value Input` setting for more dynamic default values
- Choose an appropriate editor type that matches your data type

## Related Blocks

- [Flow Output Block](/block-reference/input-output/output)
- [Subflow Block](/block-reference/input-output/subflow)

## Further Reading

- [Understanding Data Types](/docs/data-types)
- [Creating Reusable Subflows](/docs/subflows)
- [Best Practices for Flow Design](/docs/flow-design-best-practices)

---

---
## io/output.mdx

---
id: output
title: Flow Output Block
description: Define outputs for your flow, enabling data to be returned from workflows
sidebarTitle: Output
---
## Overview

The Flow Output Block is a crucial component for defining the outputs of a flow. Each instance of this block represents an individual output, where the value passed into it becomes part of the overall flow output. When a flow is used as a subflow, each Flow Output Block transforms into an output port on the subflow block.

## Inputs

<ParamField path="value" type="any" required>
  The value to be outputted from the flow. The data type should match the type specified in the Editor Settings.
</ParamField>

## Outputs

<ResponseField name="valueOutput" type="any">
  The value that was passed into the block. The data type matches the type specified in the Editor Settings.
</ResponseField>

## Editor Settings

<ParamField path="id" type="string" default="output" required>
  The unique identifier for the output. This ID is used when referencing the output and defines the output port name when used as a subflow.
</ParamField>

<ParamField path="dataType" type="string" default="string">
  Specifies the expected data type for the output. The input value will be coerced to this type if necessary.
</ParamField>

## Examples

### Basic Output Definition

1. Create a Text Block with the value "Hello, world!"
2. Add a Flow Output Block and set the ID to "greeting" and Data Type to "String"
3. Connect the Text Block to the Flow Output Block's Value input
4. In another flow, use a Subflow Block referencing the first flow
5. Run the second flow to see the "greeting" output with the value "Hello, world!"

## Error Handling

The Flow Output Block will generate an error if the data type of the input value doesn't match the specified Data Type in the Editor Settings.

<Warning>
  Always ensure that the input value matches the specified Data Type to avoid runtime errors.
</Warning>

## FAQ

<AccordionGroup>
  <Accordion title="Can I have multiple Flow Output Blocks in a flow?">
    Yes, you can have multiple Flow Output Blocks in a flow. Each block represents an individual output of the flow. Ensure that each Flow Output Block has a unique ID.
  </Accordion>

  <Accordion title="What happens if the ID of a Flow Output Block is not unique?">
    If multiple Flow Output Blocks have the same ID, the flow's output will contain the value of the last processed block with that ID.
  </Accordion>

  <Accordion title="Can I use the Flow Output Block to output complex data types?">
    Yes, the Flow Output Block can output any data type, including arrays and objects. Make sure to set the appropriate Data Type in the Editor Settings.
  </Accordion>
</AccordionGroup>

## See Also

- [Input Block](/block-reference/input-output/input)
- [Subflow Block](/block-reference/input-output/subflow)
- [Data Types](/user-guide/workflow/data-types)

---

---
## io/confirm.mdx

---
id: confirm
title: Confirm Block
description: Prompt the user for confirmation and control flow based on their response
sidebarTitle: Confirm
---
## Overview
The Confirm Block is a user input block that prompts the user for confirmation. It returns either true or false based on the user's response, making it useful for controlling flow in your application based on user inputs.

## Inputs

<ParamField path="prompt" type="string" optional>
  The message to display to the user when prompting for confirmation. Only available when "Use Input" is enabled.
</ParamField>

<ParamField path="wait" type="any" optional>
  A value to wait for before showing the confirmation prompt. Only available when "Wait For Input" is enabled.
</ParamField>

<ParamField path="value" type="string" optional>
  A value that will be passed through to either the True or False output depending on the user's response.
</ParamField>

## Outputs

<ResponseField name="output" type="any">
  The `value` input is passed through this output if the user confirms positively.
</ResponseField>

<ResponseField name="falseOutput" type="any">
  The `value` input is passed through this output if the user confirms negatively.
</ResponseField>

## Editor Settings

<ParamField path="prompt" type="string" default="Please confirm to continue.">
  The message to display to the user when prompting for confirmation. Only editable when "Use Input" is disabled.
</ParamField>

<ParamField path="useInput" type="boolean" default={false}>
  When enabled, allows the prompt message to be provided via the prompt input port instead of the editor settings.
</ParamField>

<ParamField path="useWaitForInput" type="boolean" default={false}>
  When enabled, delays showing the confirmation prompt until the "Wait For" input receives a value.
</ParamField>

<ParamField path="renderingFormat" type="string" optional>
  The format to render the prompt in. Can be either "preformatted" or "markdown".
</ParamField>

## Example: Confirming a Delete Action

1. Add a Confirm Block to your flow before a critical delete action.
2. Set the `prompt` to "Are you sure you want to delete this item? This action cannot be undone."
3. Connect your delete action to the `value` input
4. The delete action will only execute if the user confirms positively via the `output` port. The `falseOutput` port can be used to handle the negative confirmation case.

## Error Handling

The Confirm Block does not typically produce errors as it simply waits for user input. However, if there are issues with the user interface or the block fails to receive a response, it may timeout and return an error.

<Warning>
  Always provide clear and concise messages to users to ensure they understand the implications of their confirmation or denial.
</Warning>

## FAQ

<AccordionGroup>
  <Accordion title="What's the difference between using the prompt setting vs input?">
    When "Use Input" is disabled, the prompt message is set statically in the editor settings. When enabled, the prompt can be dynamically provided via the prompt input port.
  </Accordion>

  <Accordion title="How does the Wait For Input feature work?">
    When "Wait For Input" is enabled, the confirmation prompt won't be shown until a value is received on the "Wait For" input port. This allows you to sequence confirmations after other operations complete.
  </Accordion>

  <Accordion title="What happens to the value input?">
    The value input is passed through to either the True or False output depending on how the user responds to the confirmation prompt. This allows you to conditionally route data based on user confirmation.
  </Accordion>
</AccordionGroup>

## See Also

- [User Input Block](/block-reference/input-output/user-input)
- [Conditional Block](/block-reference/logic/conditional)
- [Text Block](/block-reference/data/text)

---

---
## io/upload-file.mdx

---
id: upload-file
title: Upload File Block
description: Allow users to upload files for use in your workflow
sidebarTitle: Upload File
---
## Overview

The Upload File Block is a user input component that prompts users to upload a file. It's designed to wait for the user to select and upload a file before proceeding with the workflow. This block is particularly useful when you need to incorporate user-provided files into your flow for further processing or analysis.

## Inputs

<ParamField path="questions" type="string[]" optional>
  The questions/prompts to display to the user. Only available when "Use Input" is enabled.
</ParamField>

<ParamField path="wait" type="any" optional>
  A value to wait for before showing the file upload prompt. Only available when "Wait For Input" is enabled.
</ParamField>

## Outputs

<ResponseField name="output" type="file">
  The uploaded file data. This can be used in subsequent blocks for processing or analysis.
</ResponseField>

## Editor Settings

<ParamField path="prompt" type="string" default="This is an example question?">
  The message displayed to the user when prompted to upload a file. Only editable when "Use Input" is disabled.
</ParamField>

<ParamField path="useInput" type="boolean" default={false}>
  When enabled, allows the prompt message to be provided via the questions input port instead of the editor settings.
</ParamField>

<ParamField path="useWaitForInput" type="boolean" default={false}>
  When enabled, delays showing the file upload prompt until the "Wait For" input receives a value.
</ParamField>

<ParamField path="acceptedFileTypes" type="string[]" default={["application/pdf", "application/msword", "text/csv", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"]}>
  The file types that the block will accept. Default supported types:
  - PDF files (application/pdf)
  - Microsoft Word documents (application/msword)
  - CSV files (text/csv) 
  - Modern Word documents (.docx)
</ParamField>

## Example: Uploading a CSV for Analysis

1. Add an Upload File Block to your flow.
2. Set the `prompt` to "Please upload a CSV file for analysis".
3. Connect the `output` to subsequent blocks to process the uploaded file.
4. When the flow runs, users will be prompted to upload a file matching the accepted types.## Error Handling

- If a user attempts to upload a file type that is not in the accepted file types list, the block will display an error message and continue waiting for a valid file.
- If there are issues with file upload (e.g., network errors, file corruption), the block will fail and provide error details.

<Warning>
  Always validate and sanitize uploaded files before processing them further in your workflow to ensure security and data integrity.
</Warning>

## FAQ

<AccordionGroup>
  <Accordion title="What's the difference between using the prompt setting vs input?">
    When "Use Input" is disabled, the prompt message is set statically in the editor settings. When enabled, the prompts can be dynamically provided via the questions input port.
  </Accordion>

  <Accordion title="How does the Wait For Input feature work?">
    When "Wait For Input" is enabled, the file upload prompt won't be shown until a value is received on the "Wait For" input port. This allows you to sequence file uploads after other operations complete.
  </Accordion>

  <Accordion title="What file types are supported?">
    By default, the block accepts PDF files, Microsoft Word documents (both .doc and .docx formats), and CSV files. The accepted file types are configured through the MIME types in the block settings.
  </Accordion>
</AccordionGroup>

## See Also

- [Table Block](/block-reference/data/table)
- [Text Block](/block-reference/data/text)
- [File Block](/block-reference/data/file)

---

---
## logic/race-inputs.mdx

---
id: race-inputs
title: Race Inputs Block
description: Handle multiple inputs and output the value of the first input to finish
sidebarTitle: Race Inputs
---

## Overview
The Race Inputs Block is used to handle multiple inputs and output the value of the first input to finish, force-cancelling the other inputs. This block is particularly useful when you have multiple operations that can potentially fulfill the same requirement, and you want to use the result of the operation that finishes first.

## Key Features

- Dynamically creates input ports based on connections
- Outputs the first completed input value
- Cancels remaining inputs after first completion
- Hidden by default in the block menu
- Belongs to the Logic group

## Inputs

<ParamField path="Input [i]" type="any">
  The ith input to be raced. The number of inputs is dynamic based on the connections made to the block. Each input port is labeled as "Input 1", "Input 2", etc.
</ParamField>

## Outputs

<ResponseField name="Result" type="any">
  The value of the first input to finish. If no inputs finish or all inputs are control-flow-excluded, this output will be control-flow-excluded.
</ResponseField>

## Editor Settings

<ParamField path="Hidden" type="boolean" default={true}>
  Whether the block is hidden in the block menu. This block is hidden by default.
</ParamField>

<ParamField path="Width" type="number" default={300}>
  The width of the block in pixels.
</ParamField>

## Example: Race two Chats

1. Create a new flow and add two Chat Blocks.
2. Add a Prompt Block with a quick-to-answer prompt like "What is your favorite color?" Connect it to the first Chat Block's `Prompt` input.
3. Add another Prompt Block with a longer prompt like "Describe in detail the story of Hamlet." Connect it to the second Chat Block's `Prompt` input.
4. Connect both Chat Block outputs to a Race Inputs block.
5. Run the flow. The first Chat will finish quickly, and the Race Inputs block will output its response. The second Chat Block gets canceled.

## Error Handling

The Race Inputs Block will not error if none of the inputs finish. Instead, the `Result` output will be control-flow-excluded. If all inputs are control-flow-excluded, the output will also be control-flow-excluded.

## Technical Details

- Input ports are dynamically created based on the highest numbered connected input port plus one
- Input ports are named "input1", "input2", etc.
- The output port is named "result"

## FAQ

<AccordionGroup>
  <Accordion title="What happens if none of the inputs finish?">
    If none of the inputs finish, the Race Inputs Block will not error. The `Result` output will be control-flow-excluded.
  </Accordion>

  <Accordion title="Can I use the Race Inputs Block with inputs of different data types?">
    Yes, the Race Inputs Block can handle inputs of any data type.
  </Accordion>

  <Accordion title="What happens if one of the inputs errors?">
    If one of the inputs errors, the Race Inputs Block will not be affected. It will still output the value of the first input to finish, regardless of whether other inputs error.
  </Accordion>
</AccordionGroup>

## See Also

- [HTTP Call Block](/block-reference/logic/http-call)
- [If Block](/block-reference/logic/if)
- [Match Block](/block-reference/logic/match)
- [Coalesce Block](/block-reference/logic/coalesce)

---

---
## logic/delay.mdx

---
id: delay
title: Delay Block
description: Introduce a timed delay in the execution of your workflow
sidebarTitle: Delay
---
## Overview
The Delay Block introduces a specified pause in the execution of your workflow. It accepts any number of inputs and, after the set delay, passes these input values to the outputs without modification. This block is particularly useful for controlling the timing and pacing of your workflow execution.

## Inputs

<ParamField path="Delay (ms)" type="number">
  The delay time in milliseconds. This input is only available if the "Use Delay Input" setting is enabled.
</ParamField>

<ParamField path="Input [i]" type="any">
  The ith input that will be passed to the corresponding output. The number of inputs is dynamic based on the connections made to the block.
</ParamField>

## Outputs

<ResponseField name="Output [i]" type="any">
  The ith output from the execution of the delay block. Each output corresponds to its respective input and is returned after the specified delay. The number of outputs matches the number of inputs minus 1.
</ResponseField>

## Editor Settings

<ParamField path="Delay (ms)" type="number" default={0}>
  The delay time in milliseconds. This value is used if the "Use Delay Input" setting is disabled.
</ParamField>

<ParamField path="Use Delay Input" type="boolean" default={false}>
  If enabled, adds a "Delay (ms)" input port that can override the delay time specified in settings.
</ParamField>

## Example: Delaying a Message

1. Add a Text block to your flow and set its value to "Hello, World!".
2. Add a Delay block and set its "Delay" setting to 5000 (5 seconds).
3. Connect the output of the Text block to the first input of the Delay block.
4. Run the flow. You'll notice that the output of the Delay block appears after a 5-second pause.

## Error Handling

The Delay block is designed to handle inputs robustly and doesn't generate errors under normal circumstances. If a negative delay time is provided, it will be treated as zero, resulting in immediate execution.

## FAQ

<AccordionGroup>
  <Accordion title="What happens if I set the delay time to zero?">
    If the delay time is set to zero, the Delay block will pass the input to the output immediately, effectively acting as a pass-through block.
  </Accordion>

  <Accordion title="Can I use the Delay block to throttle API calls?">
    Yes, the Delay block can be used to throttle API calls. For instance, if you have a workflow that makes frequent API calls, you can use the Delay block to ensure that calls are not made more often than a specified interval.
  </Accordion>
</AccordionGroup>

## See Also

- [Passthrough Block](./passthrough)
- [Race Inputs Block](./race-inputs)

---

---
## logic/passthrough.mdx

---
id: passthrough
title: Passthrough Block
description: Pass input values through without modification
sidebarTitle: Passthrough
---
## Overview
The Passthrough Block is a simple utility that passes input values to outputs without any modifications. It's useful for scenarios where you need to route values through specific paths in your flow without altering them, such as grouping values from different branches or controlling wire flow.

## Key Features

- Dynamically creates input and output ports based on connections
- Passes values through without modification
- Hidden by default in the block menu
- Useful for organizing complex flows

## Inputs

<ParamField path="Input [i]" type="any">
  The ith input to be passed through. The number of inputs is dynamic based on the connections made to the block. Each input port is labeled as "Input 1", "Input 2", etc.
</ParamField>

## Outputs

<ResponseField name="Output [i]" type="any">
  The ith output from the passthrough. Each output corresponds to its respective input, passing through the exact same value. The number of outputs is always one less than the number of inputs.
</ResponseField>

## Editor Settings

<ParamField path="Hidden" type="boolean" default={true}>
  Whether the block is hidden in the block menu. This block is hidden by default since it's primarily used internally.
</ParamField>

<ParamField path="Width" type="number" default={175}>
  The width of the block in pixels.
</ParamField>

## Example: Grouping Values

1. Create multiple branches in your flow that produce different values.
2. Add a Passthrough Block at the point where you want to group these values.
3. Connect the outputs from different branches to the Passthrough Block's inputs.
4. The Passthrough Block will now group these values without modifying them.

## Error Handling

The Passthrough Block does not perform any error handling. It simply passes through whatever values it receives on its inputs to the corresponding outputs. If an input is control-flow-excluded, the corresponding output will also be control-flow-excluded.

## Technical Details

- The block dynamically creates input ports based on the highest numbered connected input port plus one
- The number of output ports is always one less than the number of input ports
- Input ports are named "input1", "input2", etc.
- Output ports are named "output1", "output2", etc.
- The block belongs to the "Logic" group in the block menu

## FAQ

<AccordionGroup>
  <Accordion title="What happens if an input is missing or null?">
    If an input is missing or null, the corresponding output will also be missing or null. The Passthrough Block does not modify or validate inputs in any way.
  </Accordion>

  <Accordion title="Can the Passthrough Block be used to delay execution?">
    No, the Passthrough Block does not introduce any delay. For timed delays, consider using the Delay Block instead.
  </Accordion>

  <Accordion title="Why is this block hidden by default?">
    The Passthrough Block is primarily used internally for organizing flows and is hidden by default to avoid cluttering the block menu. However, it can still be used by directly creating it in your flow.
  </Accordion>
</AccordionGroup>

## See Also

- [If Block](/block-reference/logic/if)
- [Match Block](/block-reference/logic/match)
- [Coalesce Block](/block-reference/logic/coalesce)
- [Race Inputs Block](/block-reference/logic/race-inputs)

---

---
## logic/abort-flow.mdx

---
id: abort-flow
title: Abort Flow Block
description: Stop the execution of the entire flow immediately, either successfully or with an error
sidebarTitle: Abort Flow
---
## Overview
The Abort Flow Block is used to stop the execution of the entire flow immediately. It can either "successfully" abort the flow (early-exit), or "error" abort the flow. This block is useful for stopping the flow under certain conditions or for handling errors.

## Inputs

<ParamField path="data" type="any">
  The message to abort the graph with. If provided as a string when error aborting, this will be used as the error message.
</ParamField>

<ParamField path="successfully" type="boolean">
  Whether to successfully abort the graph (early-exit), or error abort the graph. Only available when "Use Successfully Input" is enabled in settings.
</ParamField>

## Outputs

This block does not have any outputs.

## Editor Settings

<ParamField path="Successfully Abort" type="boolean" default={true}>
  Whether to successfully abort the graph (early-exit), or error abort the graph. Can be overridden by the "successfully" input if "Use Successfully Input" is enabled.
</ParamField>

<ParamField path="Use Successfully Input" type="boolean" default={false}>
  When enabled, adds a "successfully" input port that can override the "Successfully Abort" setting.
</ParamField>

<ParamField path="Error Message" type="string">
  The error message to use when error aborting (when not successfully aborting). Only used if no message is provided via the data input.
</ParamField>

## Example: Successfully aborting a flow

1. Add an Abort Flow block to your flow.
2. Make sure the "Successfully Abort" setting is checked.
3. Connect any block to the `data` input of the Abort Flow block.
4. Run your flow. The flow will abort immediately after the Abort Flow block is processed.

## Example: Aborting a flow with an error

1. Add an Abort Flow block to your flow.
2. Uncheck the "Successfully Abort" setting.
3. Optionally, enter an error message in the "Error Message" setting.
4. Connect any block to the `data` input of the Abort Flow block.
5. Run your flow. The flow will abort with an error message.

## Error Handling

The Abort Flow Block does not produce any errors itself. However, it causes the entire flow to stop executing when it is processed, either successfully or with an error.

When error aborting, the error message is determined in this order:
1. The trimmed string value from the `data` input, if provided
2. The "Error Message" setting value, if configured
3. Default message: "Graph aborted with error"

<Warning>
  Be cautious when using this block, as it will immediately stop the execution of your entire flow.
</Warning>

## FAQ

<AccordionGroup>
  <Accordion title="What happens if I connect a non-string value to the `data` input?">
    When error aborting, non-string values will be ignored for the error message. The block will fall back to using the configured "Error Message" setting or the default error message.
  </Accordion>

  <Accordion title="What happens if I connect a block to the `successfully` input but 'Use Successfully Input' is disabled?">
    The `successfully` input port won't be available and the block will use the "Successfully Abort" setting value instead.
  </Accordion>

  <Accordion title="What happens if I don't connect anything to the `data` input or leave the 'Error Message' setting empty?">
    When error aborting, the flow will be aborted with the default error message "Graph aborted with error".
  </Accordion>
</AccordionGroup>

## See Also

- [If Block](/block-reference/logic/if)
- [If/Else Block](/block-reference/logic/if-else)
- [Race Inputs Block](/block-reference/logic/race-inputs)

---

---
## logic/loop-controller.mdx

---
id: loop-controller
title: Loop Controller Block
description: Create loops in your flow and control the iteration of values
sidebarTitle: Loop Controller
---
## Overview
The Loop Controller Block is a powerful tool that allows you to create loops in your flow. It's the only block in Odella that can contain cycles of blocks, including itself. This block maintains the state of the loop and controls the flow of values through it.

## Key Features

- Maintains loop state
- Controls value flow through the loop
- Dynamic number of input-default pairs
- Dynamic number of output ports
- Conditional loop continuation

## Inputs

<ParamField path="Continue" type="any">
  If truthy, the loop continues executing. If falsy, the loop stops. Coerced to boolean. Optional, defaults to true if not provided or if the value is "Not Ran".
</ParamField>

<ParamField path="Input X" type="any">
  The value that changes in each iteration of the loop. The number of inputs is dynamic based on connections. Each input has a corresponding default input.
</ParamField>

<ParamField path="Input X Default" type="any">
  The initial value for the corresponding Input X. Required for each Input X. If any default input is control-flow-excluded, all outputs will be control-flow-excluded.
</ParamField>

## Outputs

<ResponseField name="Break" type="any[]">
  If the `Continue` input is falsy, this output runs with an array of all input values. Does not run if `Continue` is truthy, instead outputting a control-flow-excluded value.
</ResponseField>

<ResponseField name="Iteration" type="number">
  The current iteration number, starting at 1 for the first iteration.
</ResponseField>

<ResponseField name="Output X" type="any">
  The value of the corresponding input or default input. On the first iteration, it's the value from the default input. On subsequent iterations, it's the value from the input on the previous iteration. The number of outputs matches the number of inputs.
</ResponseField>

## Editor Settings

<ParamField path="Max Iterations" type="number" default={100}>
  The maximum number of iterations the loop can run.
</ParamField>

<ParamField path="At Max Iterations" type="string" default="error">
  What should happen when max iterations is reached:
  - `error`: Throw an error (default)
  - `break`: Break the loop as if Continue was false
</ParamField>

## Example: AI Chatting To Itself

This example demonstrates a loop that continues indefinitely:

1. Add a Loop Controller block to your flow.
2. Connect a Chat block to the Loop Controller's input.
3. Combine the existing message history with the AI's response.
4. Feed the combined history back into the Loop Controller.

<Note>
  This loop will never break on its own. It will fail after 100 iterations by default unless "At Max Iterations" is set to "break".
</Note>

## Example: Iterating Over an Array

This example shows how to iterate over an array and append " Mapped" to each element:

1. Use a Pop Block to remove the first value from the array.
2. Append " Mapped" to the popped value.
3. Push the new value into an output array using an Array Block.
4. Use a Compare Block to check if the input array is empty and break the loop.
5. Connect an Output block to the `Break` output of the Loop Controller.

## Error Handling

The Loop Controller Block will error if:
- The loop exceeds the maximum number of iterations and "At Max Iterations" is set to "error"
- Any required default inputs are not connected

## FAQ

<AccordionGroup>
  <Accordion title="Why do I need to connect something to the Break output port?">
    The flow needs to traverse from the output blocks to the input block due to processing requirements. The "Break" output port provides a convenient connection point, even if the loop never breaks.
  </Accordion>

  <Accordion title="Why does my loop run forever?">
    If the "Continue" input port is not connected, it defaults to `true`, causing the loop to never break. Also, if a "Not Ran" output (e.g., from an If Block) is connected to the input port, it will always be `true`.
  </Accordion>

  <Accordion title="What happens if I don't connect the default input port?">
    If any default inputs are control-flow-excluded, all outputs will be control-flow-excluded. Always connect all default inputs.
  </Accordion>

  <Accordion title="How can I remember the ports better?">
    Input ports come in pairs (Input X and Input X Default). The block will automatically name outputs based on connected input block names.
  </Accordion>

  <Accordion title="Why does the loop controller have a maximum number of iterations?">
    This prevents accidental infinite loops. You can choose whether to error or break when the maximum is reached using the "At Max Iterations" setting.
  </Accordion>
</AccordionGroup>

## See Also

- [Loops](../user-guide/workflow/loops.md)
- [Control Flow](../user-guide/workflow/control-flow.md)

---

---
## logic/compare.mdx

---
id: compare
title: Compare Block
description: Perform comparison operations between two input values
sidebarTitle: Compare
---
## Overview
The Compare Block allows you to perform comparison operations between two input values. It supports various comparison functions including equality, inequality, less than, greater than, and logical operations such as AND, OR, XOR, NAND, NOR, and XNOR.

## Inputs

<ParamField path="A" type="any">
  The first value for comparison. Required.
</ParamField>

<ParamField path="B" type="any">
  The second value for comparison. Required.
</ParamField>

<ParamField path="Comparison Function" type="string">
  The comparison function to use. Only available when "Use Comparison Function Input" is enabled in settings.
</ParamField>

## Outputs

<ResponseField name="Output" type="boolean">
  The result of the comparison operation.
</ResponseField>

## Editor Settings

<ParamField path="Comparison Function" type="string" default="==">
  The comparison function to be used for the operation. Available options are:
  - `==`: Equal to
  - `!=`: Not equal to
  - `<`: Less than
  - `>`: Greater than
  - `<=`: Less than or equal to
  - `>=`: Greater than or equal to
  - `and`: Logical AND
  - `or`: Logical OR
  - `xor`: Logical XOR
  - `nand`: Logical NAND
  - `nor`: Logical NOR
  - `xnor`: Logical XNOR
</ParamField>

<ParamField path="Use Comparison Function Input" type="boolean" default={false}>
  When enabled, adds a "Comparison Function" input port that can override the comparison function setting.
</ParamField>

## Example: Compare two numbers

1. Create a Compare Block and set the `Comparison Function` to `>`.
2. Create two Number Blocks, one with the value `5` and the other with the value `3`.
3. Connect the Number Blocks to the `A` and `B` inputs of the Compare Block respectively.
4. Run the flow. The output of the Compare Block will be `true`, because 5 is greater than 3.

## Error Handling

If input A is not provided:
- For `==` comparison: Returns `true` if B is also not provided, `false` otherwise
- For `!=` comparison: Returns `true` if B is provided, `false` otherwise  
- For all other comparisons: Returns `false`

If the inputs are not of the same type, the block will attempt to coerce the second input (`B`) to the type of the first input (`A`).

## FAQ

<AccordionGroup>
  <Accordion title="What happens if the inputs are not of the same type?">
    If the inputs are not of the same type, the block will attempt to coerce the second input (`B`) to the type of the first input (`A`). If the coercion is not possible, the comparison will be performed with the original values.
  </Accordion>

  <Accordion title="Can I use the Compare Block to compare arrays or objects?">
    Yes, you can use the Compare Block to compare arrays or objects. The comparison will be performed using a deep equality check that compares all nested values.
  </Accordion>
</AccordionGroup>

## See Also

- [If Block](/block-reference/logic/if)
- [Match Block](/block-reference/logic/match)
- [Code Block](/block-reference/logic/code)

---

---
## logic/coalesce.mdx

---
id: coalesce
title: Coalesce Block
description: Returns the first non-null value from a list of inputs, similar to SQL's COALESCE function
sidebarTitle: Coalesce
---

## Overview
The Coalesce Block functions similarly to the `COALESCE` function in SQL, returning the first non-null value from a list of inputs. In Odella, "null" includes values that appear as "Not Ran" in the UI - blocks that have been excluded from the run due to control flow processing.

This block is particularly useful when working with a set of blocks where only one will run, allowing you to return the output of the first block that actually executes. See the examples section for more information on using this with a [Match Block](/block-reference/logic/match).

## Inputs

<ParamField path="conditional" type="boolean">
  If connected, this can be used to run the coalesce block conditionally. If not connected, it's treated like any other input. If this input is control-flow-excluded, the entire block will be control-flow-excluded.
</ParamField>

<ParamField path="input[i]" type="any">
  One of the inputs to check for nullness. The first non-null input will be passed to the output port. The number of inputs is dynamic based on how many are connected. Each input is numbered sequentially starting from 1.
</ParamField>

## Outputs

<ResponseField name="output" type="any">
  The value of the first non-null input. If all inputs are null or control-flow-excluded, the output will be control-flow-excluded.
</ResponseField>

## Editor Settings

This block has no configurable editor settings.

## Example: Default Values / Null Checks

You can use a Coalesce Block to perform null checks and set default values for a parameter.

1. Create an If block but do not connect to its input, so it will not run.
2. Connect the output of the If block to the Coalesce block.
3. Connect a Text block with a hardcoded value to the 2nd input of the Coalesce block.
4. Run the flow. The output of the Coalesce block will be the value of the Text block, since the If block was not run.

## Example: Getting a Single Value from a Match Block

1. Create a [Match Block](/block-reference/logic/match) with a few different cases, say `1`, `2`, and `3`.
2. For each case, use an [If Block](/block-reference/logic/if) to transform each case into a unique value, say `A`, `B`, and `C`. Use a [Text Block](/block-reference/data/text) connected to the `value` port of the If Blocks to set the value passed through for each case.
3. Connect the outputs of each If block to one of the inputs on a Coalesce block.
4. Connect an input to the Match block so that only one of the cases will run.
5. Run the flow. The output of the Coalesce block will be the value of the If block that ran.

This pattern is common when working with a Match block - you can get a unique value for each case using an If block, which is not dependent on the value passed into the Match block itself.

## Error Handling

The Coalesce block cannot error in normal operation.

## FAQ

<AccordionGroup>
  <Accordion title="Will an empty string be passed over?">
    No, an empty string is not considered nullable for the Coalesce Block. If you want to skip over empty strings, use an If Block to check for empty strings and return null if the string is empty.
  </Accordion>

  <Accordion title="How are inputs numbered?">
    Input ports are numbered sequentially starting from 1 (input1, input2, etc). The number of input ports automatically adjusts based on the highest numbered port that has a connection.
  </Accordion>
</AccordionGroup>

## See Also

- [Match Block](/block-reference/logic/match)
- [If Block](/block-reference/logic/if)
- [If/Else Block](/block-reference/logic/if-else)

---

---
## logic/if-else.mdx

---
id: if-else
title: If/Else Block
description: Choose between two different values based on a condition
sidebarTitle: If/Else
---
## Overview
The If/Else Block is a control flow block that allows you to choose between two different values based on a condition. It evaluates a condition and outputs either a "true" value or a "false" value depending on the result.

## Inputs

<ParamField path="If" type="any">
  If this is truthy, the `true` value will be passed through the output port. Otherwise, the `false` value will be passed through the output port. An unconnected port is considered false. A `Not Ran` value is considered false. Required.
</ParamField>

<ParamField path="True" type="any">
  The value to pass through the output port if the condition is truthy.
</ParamField>

<ParamField path="False" type="any">
  The value to pass through the output port if the condition is not truthy.
</ParamField>

## Outputs

<ResponseField name="Output" type="any">
  The `true` or `false` value, depending on the `if` condition.
</ResponseField>

## Editor Settings

<ParamField path="Don't run unconnected ports" type="boolean" default={true}>
  If enabled, unconnected input ports are control-flow-excluded. If disabled (legacy behavior), unconnected ports will pass through undefined values.
</ParamField>

## Example: Choose between two values based on a condition

1. Create a Bool Block and set its value to `true`.
2. Create two Text Blocks with values `Hello` and `World`.
3. Create an If/Else Block. Connect the Bool Block to `If`, `Hello` to `True`, and `World` to `False`.
4. Run the flow. The output should be `Hello`.
5. Change the Bool Block to `false` and run again. The output should now be `World`.

## Error Handling

The If/Else block will not throw an error under normal circumstances. If both the true and false values are unconnected or control-flow-excluded, the output will be control-flow-excluded.

## FAQ

<AccordionGroup>
  <Accordion title="What is considered truthy in Odella?">
    The following values are considered truthy:
    - Boolean `true`
    - Any non-zero number
    - Any non-empty string
    - Any non-empty Array
    - Any object with a truthy value
    - Any function

    The following are considered falsy:
    - Boolean `false` 
    - Zero
    - Empty string
    - Empty array
    - null/undefined
    - The string value `"false"`
    - `Not Ran` values
  </Accordion>

  <Accordion title="What happens if the `If` input is `Not Ran`?">
    If the `If` input is `Not Ran`, the `False` value will be passed through instead. If the `False` value is not connected and "Don't run unconnected ports" is enabled, then the result will be control-flow-excluded.
  </Accordion>

  <Accordion title="Can I use the If/Else Block to choose between two different types of values?">
    Yes, you can use the If/Else Block to choose between two different types of values. For example, you can use it to choose between a string and a number based on a condition. The output type will match whichever value (true or false) is passed through.
  </Accordion>
</AccordionGroup>

## See Also

- [If Block](/block-reference/logic/if)
- [Match Block](/block-reference/logic/match)
- [Coalesce Block](/block-reference/logic/coalesce)
- [Control Flow](/docs/user-guide/workflow/control-flow)

---

---
## logic/match.mdx

---
id: match
title: Match Block
description: Route control flow based on string matching against regular expressions
sidebarTitle: Match
---
## Overview
The Match Block is used to route control flow based on matching a string input against a series of regular expressions. Each regular expression corresponds to an output of the block. This block is particularly useful for directing workflow based on the content of a string, such as checking for specific keywords in a user's message.

## Key Features

- Match string input against multiple regular expressions
- Option to run either the first matching output or all matching outputs
- Fallback 'Unmatched' output for when no match is found
- Flexible value passing through matched outputs

## Inputs

<ParamField path="Test" type="string" required>
  The value that will be tested against each of the cases. Non-string inputs will be coerced to strings.
</ParamField>

<ParamField path="Value" type="any">
  The value passed through to the output port that matches. If unconnected, the test value will be passed through.
</ParamField>

## Outputs

<ResponseField name="Case [i]" type="any">
  The value (or test if value is unconnected) passed through if the test value matches the corresponding regex case. The number of these outputs is dynamic based on the number of configured cases. Each output is labeled with its corresponding regex pattern, or "Case N" if the pattern is empty.
</ResponseField>

<ResponseField name="Unmatched" type="any">
  The value (or test if value is unconnected) passed through if no regexes match. Will not run if any match is found.
</ResponseField>

## Editor Settings

<ParamField path="Exclusive" type="boolean" default={false}>
  If enabled, only the first matching branch will be ran. If disabled, all matching cases will run.
</ParamField>

<ParamField path="Cases" type="string[]" default={["YES", "NO"]}>
  The list of regular expressions to match against. Each case corresponds to an output port.
</ParamField>

## Example: Route control flow based on AI input

1. Create a Chat Block with a prompt asking about preference for cats or dogs.
2. Connect the Chat Block's `Message` output to a Match Block's `Test` input.
3. Set up the Match Block with regex cases for "cats" and "dogs".
4. Create three pairs of If Blocks and Text Blocks for different outcomes.
5. Connect the Match Block's outputs to the corresponding If Blocks.
6. Run the flow to see the routing based on the AI's response.## Error Handling

The Match Block will error if the `Test` input is not provided. If no match is found, the `Unmatched` output will be executed.

## FAQ

<AccordionGroup>
  <Accordion title="Can multiple cases match at once?">
    Yes, multiple cases can match simultaneously. All corresponding output ports will be executed unless the 'Exclusive' setting is enabled.
  </Accordion>

  <Accordion title="Can I use the Match Block with numbers or lists?">
    Yes, but inputs will be coerced into strings for matching. For lists, each string is typically placed on its own line for testing.
  </Accordion>
</AccordionGroup>

## See Also

- [If Block](/block-reference/logic/if)
- [If/Else Block](/block-reference/logic/if-else)
- [Loop Controller Block](/block-reference/logic/loop-controller)
- [Coalesce Block](/block-reference/logic/coalesce)
- [Control Flow](/docs/user-guide/workflow/control-flow)

---

---
## logic/switch.mdx

---
id: switch
title: Switch Block
description: Route control flow based on a boolean condition
sidebarTitle: Switch
---
## Overview
The Switch Block is a control flow block that routes the input value to different outputs based on a boolean condition. It evaluates the condition and directs the value to either the True or False output port accordingly.

## Key Features

- Routes values based on a condition
- Control flow excluded values for unmatched paths

## Inputs

<ParamField path="Condition" type="any">
  If this is truthy, the value will be passed through the True port. Otherwise, it will be passed through the False port. An unconnected port is considered false.
</ParamField>

<ParamField path="Value" type="any">
  The value to pass through the True or False port. If unconnected, it will be undefined.
</ParamField>

## Outputs

<ResponseField name="True" type="any">
  The `value` passed through if the condition is truthy. Control-flow-excluded if condition is falsy.
</ResponseField>

<ResponseField name="False" type="any">
  The `value` passed through if the condition is falsy. Control-flow-excluded if condition is truthy.
</ResponseField>

## Editor Settings

<ParamField path="Don't run unconnected value" type="boolean" default={true}>
  If enabled, unconnected value input is control-flow-excluded. If disabled (legacy behavior), unconnected value will pass through undefined.
</ParamField>

<ParamField path="Width" type="number" default={150}>
  The width of the block in pixels.
</ParamField>

## Example: Route a message based on a condition

1. Create a Bool Block and set its value to `true`.
2. Create a Text Block with the value "Hello, World!".
3. Create a Switch Block. Connect the Bool Block to `Condition` and the Text Block to `Value`.
4. Add two Text Blocks to display the output, one connected to True and one to False.
5. Run the flow. The "Hello, World!" message should appear in the Text Block connected to True.
6. Change the Bool Block to `false` and run again. The message should now appear in the Text Block connected to False.

## Error Handling

The Switch block will not throw an error under normal circumstances. The following values are considered falsy:

- Boolean `false`
- Empty string
- Empty array
- Control-flow-excluded values
- Undefined/unconnected inputs
- Empty chat messages

## FAQ

<AccordionGroup>
  <Accordion title="What happens if the Value input is not provided?">
    If "Don't run unconnected value" is enabled (default), the value will be control-flow-excluded. If disabled, undefined will be passed through.
  </Accordion>

  <Accordion title="Can I use complex conditions with the Switch block?">
    The Switch block accepts any input type for the condition and coerces it to a boolean. For complex conditions, you may want to evaluate them before the Switch block.
  </Accordion>
</AccordionGroup>

## See Also

- [If/Else Block](/block-reference/logic/if-else)
- [Match Block](/block-reference/logic/match)
- [Bool Block](/block-reference/data/bool)

---

---
## agents/auto-system-prompt.mdx

---
id: auto-system-prompt
title: Auto System Prompt Block
description: Automatically generate system prompts to improve AI model guidance
sidebarTitle: Auto System Prompt
---
## Overview
The Auto System Prompt Block is designed to automatically generate system prompts that enhance the guidance for AI models in other blocks, such as the Ask AI Block. By taking a user-provided prompt as input, this block creates a tailored system prompt that helps define the goal and context for the AI model, resulting in more focused and relevant outputs.## Inputs

<ParamField path="Input" type="string" required>
  A question and/or task for the agent to complete. Required. The input can be provided as:
  - A string
  - An array of strings (will be joined with newlines)
  - A chat message
  - An array of chat messages (messages will be joined with newlines)
  Other input types will be coerced to strings when possible.
</ParamField>

## Outputs

<ResponseField name="Name" type="string">
  The name of the generated agent, typically including an emoji indicating its specialty (e.g. "💰 Finance Agent").
</ResponseField>

<ResponseField name="System Prompt" type="string">
  The generated role/system prompt for the agent, tailored to the input task.
</ResponseField>

<ResponseField name="Duration" type="number">
  The time in milliseconds that the block took to execute.
</ResponseField>

## Editor Settings

<ParamField path="GPT Model" type="string" default="gpt-3.5-turbo">
  The specific GPT model to use for generating the system prompt. Available models are dynamically populated based on the LLM provider configuration. Has a "Use Input" toggle to accept the model via input instead.
</ParamField>

## Error Handling

The block will retry failed attempts up to 3 times with exponential backoff when encountering errors:

- For rate limit (429) errors, it will display "API rate limit exceeded, retrying..."
- For timeout (408) errors, it will display "API timed out, retrying..."
- Other 4xx errors will fail immediately with an error message
- The maximum retry time is 5 minutes

## Default Values

If the AI fails to generate a proper response, the block will fall back to these defaults:

- Default Name: "Default Agent"
- Default Role: "You are an AI critical thinker research assistant. Your sole purpose is to write well written, critically acclaimed, objective and structured reports on given text."

## Notes

- The block requires an LLM provider to be configured in the workflow context
- The block will automatically coerce various input types to strings
- The generated agent roles are tailored to specific domains (finance, business, travel, etc.)
- The block supports legal expertise and can target specific legal specialties when applicable

## Example Usage

1. Connect a Text block containing your task/question to the Input port
2. Select your desired GPT model in the settings
3. Connect the Name and System Prompt outputs to other blocks that need agent configuration
4. The block will generate a domain-specific agent name and role based on the input

---

---
## ai/analyze-table.mdx

---
id: analyze-table
title: Analyze Table Block
description: Leverage AI to analyze and transform tabular data based on natural language prompts
sidebarTitle: Analyze Table
---
## Overview
The Analyze Table Block uses AI capabilities to perform complex analysis and transformations on tabular data. By providing a natural language prompt, you can instruct the AI to aggregate data, calculate summary statistics, or perform other sophisticated operations on your input table.## Inputs

<ParamField path="Table" type="table" required>
  The input table to be analyzed. Should be an array of objects, where each object represents a row in the table.
</ParamField>

<ParamField path="Prompt" type="string" required>
  A natural language prompt describing the analysis or transformation to be performed on the table. This input is only available if "Use Prompt Input" is enabled in settings. The prompt guides the AI in generating the appropriate code for table analysis.
</ParamField>

## Outputs

<ResponseField name="Output" type="table">
  The resulting table after analysis or transformation. The structure of this table will depend on the operations specified in the prompt.
</ResponseField>

<ResponseField name="Duration" type="number">
  The time in milliseconds that the block took to execute.
</ResponseField>

## Editor Settings

<ParamField path="AI Model" type="string" default="default">
  The specific model to use for generating the analysis code. Available models are dynamically populated based on the LLM provider configuration.
</ParamField>

<ParamField path="Use Prompt Input" type="boolean" default={false}>
  When enabled, allows the prompt to be provided via an input port instead of being set in the settings.
</ParamField>

<ParamField path="Prompt" type="string">
  The analysis prompt to use when "Use Prompt Input" is disabled. Describe the analysis you would like to perform on the table. The AI will generate the code for you.
</ParamField>

## Requirements

- An LLM provider must be configured in the workflow context
- A code interpreter endpoint must be set in the settings (Azure Code Interpreter)

## Error Handling

The block will retry failed attempts up to 3 times with exponential backoff when encountering errors:
- Retries occur between 500ms and 5000ms apart
- Maximum of 3 retries before failing
- Error details are provided in the trace logs

Common errors include:
- Missing or invalid input table
- Failed code generation from AI
- Runtime errors in generated analysis code
- Missing configuration for LLM provider or code interpreter

<Warning>
  Always validate the output of the Analyze Table block, especially when working with critical data or making important decisions based on the results.
</Warning>

## Example Usage

1. Add an Analyze Table block to your flow
2. Connect your input table to the `Table` input
3. Either:
   - Enable "Use Prompt Input" and connect a prompt via the input port
   - Disable "Use Prompt Input" and enter your analysis prompt in settings
4. Select your desired AI model
5. Run the flow to get the analyzed table output

## FAQ

<AccordionGroup>
  <Accordion title="What types of analysis can the Analyze Table block perform?">
    The block can perform a wide range of operations using pandas, including: aggregations, filtering, sorting, pivoting, calculating summary statistics, and applying complex transformations. The capabilities are largely determined by the AI model's ability to generate appropriate pandas code.
  </Accordion>

  <Accordion title="How does the block handle date-time data?">
    The block automatically handles messy date-time formats in the input data, converting them to appropriate pandas datetime objects for analysis.
  </Accordion>

  <Accordion title="How is the analysis performed securely?">
    The analysis code is executed in an isolated Azure Code Interpreter environment. The data is processed securely within this environment and only the results are returned.
  </Accordion>
</AccordionGroup>

## See Also

- [AI Filter Block](/block-reference/ai/ai-filter)
- [Ask AI Block](/block-reference/ai/ask-ai)
- [Table Block](/block-reference/data/table)

---

---
## ai/decision.mdx

---
id: decision
title: Decision Block
description: Use AI to make binary decisions based on input values and natural language prompts
sidebarTitle: Decision
---

## Overview

The Decision Block leverages AI capabilities to make binary decisions based on input values and natural language prompts. It acts as an AI-powered equivalent of a traditional switch block, evaluating whether a condition is true or false and directing the flow accordingly.
## Inputs

<ParamField path="System Prompt" type="string">
  The system prompt to send to the model. Optional. Used to provide high-level guidance to the AI model.
</ParamField>

<ParamField path="Condition Prompt" type="any" required>
  A prompt outlining a TRUE/FALSE decision criteria. Required. The prompt must satisfy a condition to be satisfied.
</ParamField>

<ParamField path="Value" type="any" required>
  The value to pass through the True or False port. Required. If unconnected, it will be undefined.
</ParamField>

## Outputs

<ResponseField name="True" type="any">
  The `value` passed through if the condition is truthy.
</ResponseField>

<ResponseField name="False" type="any">
  The `value` passed through if the condition is falsy.
</ResponseField>

<ResponseField name="Cost" type="number">
  The total cost of the AI operations in USD.
</ResponseField>

<ResponseField name="Duration" type="number">
  The time in milliseconds that the block took to execute.
</ResponseField>

## Editor Settings

<ParamField path="Don't run unconnected value" type="boolean" default={true}>
  When enabled, unconnected values will be excluded from control flow.
</ParamField>

<ParamField path="AI Model" type="string" default="gpt-3.5-turbo">
  The AI model used to evaluate the decision. Available models are dynamically populated based on the LLM provider configuration. Uses a custom LLM dropdown element.
</ParamField>

## Error Handling

The block will retry failed attempts up to 3 times with exponential backoff:
- Minimum retry delay: 500ms
- Maximum retry delay: 5000ms
- Retry factor: 2.5x
- Includes randomization
- Maximum retry time: 5 minutes

Error messages will be logged for:
- Invalid responses (must contain TRUE or FALSE)
- Missing LLM provider configuration
- Token limit exceeded errors
- API errors and timeouts

## Example: Categorizing Customer Feedback

1. Add a Decision block to your flow.
2. Connect your input text (customer feedback) to the `Value` input of the Decision block.
3. Add a Text block with a prompt like "Determine if this customer feedback is positive" and connect it to the `Condition Prompt` input.
4. Connect the `True` output to a block that handles positive feedback.
5. Connect the `False` output to a block that handles negative feedback.
6. Run your flow. The Decision block will evaluate each piece of feedback and direct it to the appropriate handling process.

## Notes

- Token counts are checked against model limits before execution
- Costs are calculated per-token based on model pricing
- Responses are case-insensitive but must contain TRUE or FALSE
- System prompts are optional but can help guide the model
- Cache can be enabled/disabled per model configuration

<Warning>
  While the Decision block can handle complex decision-making tasks, it's important to validate its decisions for critical applications and provide clear, unambiguous prompts.
</Warning>

## FAQ

<AccordionGroup>
  <Accordion title="How does the Decision block differ from a traditional switch block?">
    Unlike a traditional switch block that uses predefined conditions, the Decision block uses AI to interpret natural language prompts and make decisions based on more complex or nuanced criteria.
  </Accordion>

  <Accordion title="Can the Decision block handle multiple conditions or outcomes?">
    The Decision block is designed for binary (true/false) decisions. For more complex decision trees, you can chain multiple Decision blocks together.
  </Accordion>

  <Accordion title="How accurate is the Decision block?">
    The accuracy depends on the clarity of the prompt, the complexity of the decision, and the capabilities of the chosen AI model. It's recommended to test thoroughly and adjust prompts as needed for optimal performance.
  </Accordion>
</AccordionGroup>

## See Also

- [Switch Block](/block-reference/logic/switch)
- [Ask AI Block](/block-reference/ai/ask-ai)
- [AI Filter Block](/block-reference/ai/ai-filter)

---

---
## ai/ask-ai.mdx

---
id: ask-ai
title: Ask AI Block
description: Send messages to over 250 AI models for chat completions
sidebarTitle: Ask AI
---

## Overview

The Ask AI Block allows you to send messages to over 250 different AI models for chat completions. This versatile block provides a wide range of options for AI-powered conversations and text generation tasks.
## Inputs

<ParamField path="systemPrompt" type="string | chat-message">
  The system prompt to send to the model. Optional. Used to provide high-level guidance to the AI model.
</ParamField>

<ParamField path="prompt" type="string | string[] | chat-message | chat-message[]">
  The prompt message or messages to send to the model. Required. Strings will be converted into chat messages of type `user`, with no name.
</ParamField>

<ParamField path="model" type="string">
  The model to use for the chat. Only available when "Use Model Input" is enabled.
</ParamField>

<ParamField path="temperature" type="number">
  What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. Only available when "Use Temperature Input" is enabled.
</ParamField>

<ParamField path="top_p" type="number">
  An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered. Only available when "Use Top P Input" is enabled.
</ParamField>

<ParamField path="useTopP" type="boolean">
  Whether to use top p sampling, or temperature sampling. Only available when "Use Top P Input" is enabled.
</ParamField>

<ParamField path="maxTokens" type="number">
  The maximum number of tokens to generate in the chat completion. Only available when "Use Max Tokens Input" is enabled.
</ParamField>

<ParamField path="stop" type="string">
  A sequence where the API will stop generating further tokens. Only available when "Use Stop Input" is enabled.
</ParamField>

<ParamField path="presencePenalty" type="number">
  Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics. Only available when "Use Presence Penalty Input" is enabled.
</ParamField>

<ParamField path="frequencyPenalty" type="number">
  Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim. Only available when "Use Frequency Penalty Input" is enabled.
</ParamField>

<ParamField path="seed" type="number">
  If specified, OpenAI will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result. Only available when "Use Seed Input" is enabled.
</ParamField>

## Outputs

<ResponseField name="response" type="string">
  The textual response from the model.
</ResponseField>

<ResponseField name="in-messages" type="chat-message[]">
  All messages sent to the model.
</ResponseField>

<ResponseField name="all-messages" type="chat-message[]">
  All messages, with the response appended.
</ResponseField>

<ResponseField name="responseTokens" type="number">
  The number of tokens in the response from the LLM. For a multi-response, this is the sum.
</ResponseField>

<ResponseField name="cost" type="number">
  The estimated cost of the API call in USD.
</ResponseField>

<ResponseField name="duration" type="number">
  The time taken to complete the request in milliseconds.
</ResponseField>

## Editor Settings

<ParamField path="Model" type="string">
  The AI model to use for responses. Choose from over 250 available models across various providers.
</ParamField>

<ParamField path="Use Prompt Input" type="boolean" default={true}>
  Whether to use the prompt input, or input a prompt directly in the settings.
</ParamField>

<ParamField path="Temperature" type="number" default={0.7} min={0} max={2} step={0.1}>
  Controls randomness in the output. Lower values make the output more focused and deterministic.
</ParamField>

<ParamField path="Top P" type="number" default={1} min={0} max={1} step={0.1}>
  Alternative to temperature sampling. Only tokens comprising the top P probability mass are considered.
</ParamField>

<ParamField path="Use Top P" type="boolean" default={false}>
  Whether to use top p sampling instead of temperature sampling.
</ParamField>

<ParamField path="Max Tokens" type="number" default={8192}>
  The maximum number of tokens to generate in the completion.
</ParamField>

<ParamField path="Stop" type="string">
  A sequence where the API will stop generating further tokens.
</ParamField>

<ParamField path="Presence Penalty" type="number" min={-2} max={2} step={0.1}>
  Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
</ParamField>

<ParamField path="Frequency Penalty" type="number" min={-2} max={2} step={0.1}>
  Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
</ParamField>

<ParamField path="Seed" type="number" step={1}>
  If specified, OpenAI will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
</ParamField>

### Advanced

<ParamField path="Custom Max Tokens" type="number">
  Overrides the max number of tokens a model can support. Leave blank for preconfigured token limits.
</ParamField>

<ParamField path="Cache Responses" type="boolean" default={false}>
  If enabled, requests with the same parameters and messages will be cached for immediate responses without an API call.
</ParamField>

<ParamField path="Use for subgraph partial output" type="boolean">
  If enabled, streaming responses from this node will be shown in Subgraph nodes that call this graph.
</ParamField>

## Example: Simple Question Answering

1. Add an Ask AI block to your flow.
2. Add a Text block and enter your question in its editor.
3. Connect the output of the Text block to the `Prompt` input of the Ask AI block.
4. Select your desired model in the Ask AI block settings.
5. Run your flow. The AI's response will appear at the bottom of the Ask AI block.

## Error Handling

The block will retry failed attempts up to 3 times with exponential backoff:
- Minimum retry delay: 500ms
- Maximum retry delay: 5000ms
- Retry factor: 2.5x
- Includes randomization
- Maximum retry time: 5 minutes

Error messages will be logged for:
- Missing prompt input
- API rate limits (will retry)
- API timeouts (will retry) 
- Token limit exceeded
- Invalid model configuration
- Other API errors

<Warning>
  Be mindful of rate limits when using the Ask AI block, especially when [batching](/workflow/batching) requests.
</Warning>

## FAQ

<AccordionGroup>
  <Accordion title="Can I use multiple AI models in the same workflow?">
    Yes, you can use multiple Ask AI blocks with different models in the same workflow.
  </Accordion>

  <Accordion title="What happens if I connect an unsupported data type to the prompt input?">
    The block will attempt to convert the value to a string. If successful, it will be treated as a user message. If conversion fails, the input will be ignored.
  </Accordion>

  <Accordion title="Are all settings available for all models?">
    No, available settings may vary depending on the selected model. The block will adapt its settings based on your selection.
  </Accordion>
</AccordionGroup>

## See Also

- [Text Block](/block-reference/data/text)
- [Assemble Prompt Block](/block-reference/ai/assemble-prompt)
- [AI Filter Block](/block-reference/ai/ai-filter)

---

---
## ai/extract-data.mdx

---
id: extract-data
title: Extract Data Block
description: Leverage AI to extract structured data from unstructured text based on a flexible schema
sidebarTitle: Extract Data
---

## Overview

The Extract Data Block uses AI capabilities to extract structured data from unstructured text input. By defining a flexible schema, you can specify which fields to extract, their data types, and provide detailed descriptions to guide the AI model in accurately extracting the desired information.
## Inputs

<ParamField path="systemPrompt" type="string">
  The system prompt to send to the model. Optional. Used to provide high-level guidance to the AI model.
</ParamField>

<ParamField path="context" type="string" required>
  The context to extract the specified schema(s) from. Required.
</ParamField>

## Outputs

<ResponseField name="all" type="object[]">
  An array of objects containing all extracted data, structured according to the defined schema.
</ResponseField>

<ResponseField name="[schemaField]" type="any[]">
  For each field defined in the schema, an array containing the extracted values for that field. The type will match the schema field type.
</ResponseField>

<ResponseField name="duration" type="number">
  The time in milliseconds that the block took to execute.
</ResponseField>

## Editor Settings

<ParamField path="AI Model" type="string" default="gpt-3.5-turbo">
  The AI model to use for data extraction. Available models are dynamically populated based on the LLM provider configuration.
</ParamField>

<ParamField path="Schema" type="object">
  The schema defining what data to extract. Specify field names, types, and descriptions to guide the extraction.
</ParamField>

### Parameters

<ParamField path="Temperature" type="number" default={0} min={0} max={2} step={0.1}>
  What sampling temperature to use. Higher values like 0.8 make output more random, while lower values like 0.2 make it more focused and deterministic.
</ParamField>

<ParamField path="Top P" type="number" default={1} min={0} max={1} step={0.1}>
  Alternative to temperature sampling. Only tokens comprising the top P probability mass are considered. For example, 0.1 means only tokens in the top 10% probability are considered.
</ParamField>

<ParamField path="Use Top P" type="boolean" default={false}>
  Whether to use top p sampling instead of temperature sampling.
</ParamField>

<ParamField path="Max Tokens" type="number" default={8192}>
  The maximum number of tokens to generate in the completion.
</ParamField>

<ParamField path="Stop" type="string">
  A sequence where the API will stop generating further tokens.
</ParamField>

<ParamField path="Presence Penalty" type="number" min={-2} max={2} step={0.1}>
  Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
</ParamField>

<ParamField path="Frequency Penalty" type="number" min={-2} max={2} step={0.1}>
  Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
</ParamField>

<ParamField path="Seed" type="number" step={1}>
  If specified, OpenAI will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
</ParamField>

### Advanced

<ParamField path="Cache Responses" type="boolean" default={false}>
  If enabled, requests with the same parameters and messages will be cached for immediate responses without an API call.
</ParamField>

<ParamField path="Use for subgraph partial output" type="boolean">
  If enabled, streaming responses from this node will be shown in Subgraph nodes that call this graph.
</ParamField>

<ParamField path="Error on invalid output(s)" type="boolean">
  If enabled, the node will error if any of the results returned do not conform to the schema.
</ParamField>

## Error Handling

The block will retry failed attempts up to 3 times with exponential backoff:
- Minimum retry delay: 500ms
- Maximum retry delay: 5000ms
- Retry factor: 2.5x
- Includes randomization
- Maximum retry time: 5 minutes

Error messages will be logged for:
- Invalid schema validation
- Missing LLM provider configuration
- API errors and timeouts
- Aborted requests

<Warning>
  Always validate the output of the Extract Data block, especially when working with critical data or making important decisions based on the extracted information.
</Warning>

## Example: Extracting Contact Information

1. Add an Extract Data block to your flow.
2. Connect your input text (e.g., an email or document) to the `Context` input.
3. Define a schema in the block settings, for example:
   ```json
   {
     "name": {"type": "string", "description": "Full name of the person"},
     "email": {"type": "string", "description": "Email address"},
     "phone": {"type": "string", "description": "Phone number"},
     "company": {"type": "string", "description": "Company name"}
   }
   ```
4. Select your desired provider and model.
5. Run your flow. The block will output an object with the extracted information.

## See Also

- [Analyze Table Block](/block-reference/ai/analyze-table)
- [AI Filter Block](/block-reference/ai/ai-filter)
- [Ask AI Block](/block-reference/ai/ask-ai)

---

---
## ai/describe-image.mdx

---
id: describe-image
title: Describe Image Block
description: Leverage AI to analyze and describe images based on natural language prompts
sidebarTitle: Describe Image
---

## Overview

The Describe Image Block uses Vision Language Model (VLM) capabilities to analyze and describe images. By providing an image and an optional natural language prompt, you can instruct the AI to focus on specific aspects or provide general descriptions of the image content.## Inputs

<ParamField path="systemPrompt" type="string">
  The system prompt to send to the model. Optional. Used to provide high-level guidance to the AI model.
</ParamField>

<ParamField path="prompt" type="chat-message | chat-message[]">
  The prompt message or messages to send to the model. Only available if "Use Prompt Input" is enabled in settings.
</ParamField>

<ParamField path="image" type="image" required>
  The input image to be analyzed. Required. The image will be converted to a data URI before being sent to the model.
</ParamField>

## Outputs

<ResponseField name="output" type="string">
  The resulting description of the image. The content and focus of this description will depend on the input image and any provided prompts.
</ResponseField>

## Editor Settings

<ParamField path="model" type="string" default="gpt-4o">
  The AI vision model used to describe the image. Available models are dynamically populated based on the LLM provider configuration.
</ParamField>

<ParamField path="usePromptInput" type="boolean" default={false}>
  When enabled, allows the prompt to be provided via an input port instead of being set in the settings.
</ParamField>

<ParamField path="prompt" type="string" default="Describe the image in detail. If the image is a chart, provide an overview of the data and any trends or insights. If the image is of anything else, describe the content of the image.">
  The prompt to use when "Use Prompt Input" is disabled. This text will be sent to the model along with the image.
</ParamField>

<ParamField path="maxTokens" type="number" default={2048}>
  The maximum number of tokens to generate in the response.
</ParamField>

<ParamField path="temperature" type="number" default={0}>
  The sampling temperature to use. Lower values produce more focused and deterministic outputs, while higher values allow for more creativity in descriptions.
</ParamField>

<Note>
  Available settings may vary depending on the selected LLM provider and model.
</Note>

## Example: Analyzing a Chart Image

1. Add a Describe Image block to your flow.
2. Connect your input image (e.g., a chart or graph) to the `image` input of the Describe Image block.
3. Add a Text block with a prompt like "Describe the main trends and key data points in this chart" and connect it to the `prompt` input if using prompt input mode.
4. Select your desired model in the Describe Image block settings.
5. Run your flow. The block will output a detailed description of the chart, focusing on the trends and key data points.

## Error Handling

- If the input image is empty, invalid, or in an unsupported format, the block will return an error.
- If the AI provider fails to analyze the image, the block will retry up to 3 times with exponential backoff (1-10 seconds between retries).
- If the image is too large or complex for the model to process, the block may return an error or a partial description.

<Warning>
  Always validate the output of the Describe Image block, especially when using it for critical applications or decision-making processes.
</Warning>

## FAQ

<AccordionGroup>
  <Accordion title="What types of images can the Describe Image block analyze?">
    The block can analyze a wide variety of images, including photographs, charts, graphs, diagrams, and more. The effectiveness may vary depending on the complexity of the image and the capabilities of the chosen AI model.
  </Accordion>

  <Accordion title="How detailed are the image descriptions?">
    The level of detail in the descriptions can vary based on the complexity of the image, the specificity of the prompt (if provided), and the capabilities of the chosen AI model. You can often get more detailed or focused descriptions by using specific prompts.
  </Accordion>

  <Accordion title="Can the Describe Image block identify specific objects or people in images?">
    While the block can generally describe the contents of an image, including objects and people, it typically doesn't identify specific individuals. The level of object recognition depends on the AI model's training and capabilities.
  </Accordion>
</AccordionGroup>

## See Also

- [Create Chart Block](/block-reference/ai/create-chart)
- [Ask AI Block](/block-reference/ai/ask-ai)
- [AI Filter Block](/block-reference/ai/ai-filter)

---

---
## ai/generate-questions.mdx

---
id: generate-questions
title: Generate Questions Block
description: Leverage AI to generate multiple questions based on a given prompt and value
sidebarTitle: Generate Questions
---

## Overview

The Generate Questions Block uses AI capabilities to create a specified number of questions based on an input prompt and value. This block is particularly useful for expanding research activities, breaking down complex topics into manageable parts, or creating comprehensive question sets for various purposes.
## Inputs

<ParamField path="systemPrompt" type="string">
  The system prompt to send to the model. Optional. Used to provide high-level guidance to the AI model.
</ParamField>

<ParamField path="context" type="string | chat-message | chat-message[] | array">
  The context to generate related questions from. Optional. Can be a string, chat message, array of chat messages, or other array types that can be coerced to strings.
</ParamField>

<ParamField path="instruction" type="string">
  Available when using the "Blank" template. The instruction for generating questions.
</ParamField>

<ParamField path="question" type="string">
  Available when using the "Research Questions" template. The question to generate research queries for.
</ParamField>

## Outputs

<ResponseField name="questions" type="string[]">
  An array of generated questions based on the input context and prompts.
</ResponseField>

<ResponseField name="duration" type="number">
  The time in milliseconds that the block took to execute.
</ResponseField>

## Editor Settings

<ParamField path="AI Model" type="string" default="default">
  The AI model to use for generating questions. Available models are dynamically populated based on the LLM provider configuration. Only models supporting function calls are shown.
</ParamField>

<ParamField path="From Template" type="string" default="Research Questions">
  Choose from predefined templates:
  - Blank: A simple template with custom instruction
  - Research Questions: Template for generating Google search queries
</ParamField>

<ParamField path="Number of Questions" type="number" default={3} min={1} max={10}>
  The number of questions to generate. Must be between 1 and 10.
</ParamField>

<ParamField path="Temperature" type="number" default={0.5} min={0} max={1} step={0.1}>
  Controls randomness in the output. Lower values make the output more focused and deterministic.
</ParamField>

<ParamField path="Prompt Text" type="code">
  The prompt template text. Supports interpolation using {"{{"}variable{"}}"} syntax. Uses custom prompt interpolation highlighting.
</ParamField>

## Error Handling

The block will retry failed attempts up to 3 times with exponential backoff:
- Minimum retry delay: 500ms
- Maximum retry delay: 5000ms
- Retry factor: 2.5x
- Includes randomization
- Maximum retry time: 5 minutes

Error messages will be logged for:
- Invalid number of questions (must be 1-10)
- Empty or invalid responses
- API rate limits (will retry)
- API timeouts (will retry)
- Other API errors

<Warning>
  Always review the generated questions for relevance and appropriateness, especially when using them for critical research or decision-making processes.
</Warning>

## FAQ

<AccordionGroup>
  <Accordion title="How diverse are the generated questions?">
    The diversity of questions depends on the input prompt, the provided value, and the AI model's capabilities. You can encourage more diverse questions by adjusting the temperature setting or by providing a more open-ended prompt.
  </Accordion>

  <Accordion title="Can I generate questions in languages other than English?">
    Yes, the Generate Questions block can generate questions in various languages. Simply provide the prompt and value in your desired language, and ensure the chosen AI model supports that language.
  </Accordion>

  <Accordion title="How can I ensure the generated questions are relevant to my specific needs?">
    To improve relevance, provide a clear and specific prompt that outlines the type of questions you're looking for. You can also experiment with different AI models and settings to find the best combination for your use case.
  </Accordion>
</AccordionGroup>

## See Also

- [Ask AI Block](/block-reference/ai/ask-ai)
- [Analyze Table Block](/block-reference/ai/analyze-table)
- [AI Filter Block](/block-reference/ai/ai-filter)

---

---
## ai/ai-filter.mdx

---
id: ai-filter
title: AI Filter Block
description: Apply AI-powered filtering to arrays using various models and providers
sidebarTitle: AI Filter
---
## Overview
The AI Filter Block applies a filter operation over an array of values where the filter condition is evaluated by one of the AI models from the 250+ models Odella connects to. This powerful block allows you to leverage AI capabilities to perform complex filtering tasks on your data.## Inputs

<ParamField path="System Prompt" type="string">
  The system prompt to send to the model. Optional. Used to provide high-level guidance to the AI model.
</ParamField>

<ParamField path="Condition Prompt" type="string" required>
  The condition prompt to filter the array. Required. This prompt describes the criteria that each array element will be evaluated against.
</ParamField>

<ParamField path="Input" type="any[]" required>
  The input array to filter. Required. Can be an array of any data type.
</ParamField>

## Outputs

<ResponseField name="Indicies" type="number[]">
  The index numbers of each element that passed the filter condition.
</ResponseField>

<ResponseField name="Output" type="any[]">
  The filtered input array containing only the elements that passed the condition.
</ResponseField>

## Editor Settings

<ParamField path="AI Model" type="string" default="gpt-3.5-turbo">
  The AI model to use for evaluating filter conditions. Available models are dynamically populated based on the LLM provider configuration.
</ParamField>

<ParamField path="Temperature" type="number" default={0} min={0} max={2}>
  The sampling temperature to use. Values between 0-2. Higher values (0.8) make output more random, lower values (0.2) make it more focused and deterministic.
</ParamField>

<ParamField path="Top P" type="number" default={1} min={0} max={1}>
  Alternative to temperature sampling. Only tokens comprising the top P probability mass are considered. For example, 0.1 means only tokens in the top 10% probability are considered.
</ParamField>

<ParamField path="Use Top P" type="boolean" default={false}>
  Toggle between using top P sampling or temperature sampling.
</ParamField>

<ParamField path="Max Tokens" type="number" default={2048}>
  The maximum number of tokens to generate in each chat completion.
</ParamField>

<ParamField path="Stop" type="string">
  A sequence where the API will stop generating further tokens.
</ParamField>

<ParamField path="Presence Penalty" type="number" min={-2} max={2}>
  Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
</ParamField>

<ParamField path="Frequency Penalty" type="number" min={-2} max={2}>
  Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
</ParamField>

<ParamField path="Seed" type="number">
  If specified, the model will attempt to generate deterministic results for repeated requests with the same seed and parameters.
</ParamField>

### Advanced Settings

<ParamField path="Custom Max Tokens" type="number">
  Overrides the max number of tokens a model can support. Leave blank for preconfigured token limits.
</ParamField>

<ParamField path="Cache Responses" type="boolean" default={false}>
  If enabled, requests with the same parameters and messages will be cached for immediate responses without an API call.
</ParamField>

<ParamField path="Use for subgraph partial output" type="boolean" default={false}>
  If enabled, streaming responses from this node will be shown in Subgraph nodes that call this graph.
</ParamField>

## Error Handling

- The block will retry failed attempts up to 3 times with exponential backoff
- Token limits are automatically enforced based on the selected model
- Invalid responses (non TRUE/FALSE) from the model will trigger an error
- The block includes built-in timeout handling and request cancellation support

## Example Usage

1. Connect an array of items to the Input port
2. Add a condition prompt like "Keep only items that are environmentally sustainable products"
3. Optionally add a system prompt for additional context
4. Configure the model and parameters in the settings
5. Connect the Output port to use the filtered results

## Notes

- The block automatically handles token counting and cost tracking
- Responses are strictly evaluated as TRUE/FALSE
- The block supports parallel processing of array elements
- Built-in caching can improve performance for repeated operations

---

---
## ai/research-ai.mdx

---
id: research-ai
title: Research AI Block
description: Leverage AI to conduct intelligent research across public or private document stores
sidebarTitle: Research AI
---

## Overview

The Research AI Block utilizes advanced AI capabilities to perform intelligent searches and research across multiple document stores. This block can search through public databases, private collections, or a combination of both, providing powerful and flexible research capabilities for various use cases.
## Inputs

<ParamField path="Question" type="string | chat-message | chat-message[] | string[]" required>
  The question or questions to research. Required. This guides the AI in conducting the research. Can be provided as a string, chat message, array of chat messages, or array of strings.
</ParamField>

## Outputs

<ResponseField name="Question" type="string">
  The question that was researched.
</ResponseField>

<ResponseField name="Answer" type="string">
  The answer to the research question.
</ResponseField>

<ResponseField name="Sources" type="object[]">
  The cited sources supporting the response.
</ResponseField>

<ResponseField name="All" type="string">
  A combined output containing the question, answer and discovered sources.
</ResponseField>

<ResponseField name="Duration" type="number">
  The time in milliseconds that the block took to execute.
</ResponseField>

## Editor Settings

<ParamField path="Document Store" type="string[]">
  Select up to 5 document stores to search over. The available options are dynamically populated based on your configured document stores.
</ParamField>

<ParamField path="Mode" type="string" default="OR">
  How to combine the search results across multiple document stores:
  - OR: Routes to the most relevant store
  - AND: Combines results from all stores
</ParamField>

<Note>
  A DocumentStoreProvider must be configured to use this block.
</Note>

## Error Handling

The block will retry failed attempts up to 3 times with exponential backoff:
- Minimum retry delay: 500ms
- Maximum retry delay: 5000ms
- Retry factor: 2.5x
- Includes randomization
- Maximum retry time: 5 minutes

Error messages will be logged for:
- No document stores selected
- Invalid document store IDs
- Missing DocumentStoreProvider configuration
- API rate limits (will retry)
- API timeouts (will retry)
- Other API errors

<Warning>
  Always verify the accuracy and relevance of the research results, especially when using them for critical decision-making or legal purposes.
</Warning>

## FAQ

<AccordionGroup>
  <Accordion title="How does the Research AI block handle conflicting information from different sources?">
    The AI attempts to reconcile conflicting information by analyzing the credibility of sources, considering the recency of information, and providing context for discrepancies. In cases of significant conflicts, the AI may highlight these differences in the research results.
  </Accordion>

  <Accordion title="Can I use the Research AI block with my own private document stores?">
    Yes, the Research AI block can be configured to work with both public and private document stores. Ensure that your private stores are properly set up and accessible within your platform environment.
  </Accordion>

  <Accordion title="How does the 'OR' search mode differ from the 'AND' mode?">
    In 'OR' mode, the AI intelligently selects the most appropriate document store to search based on the query, potentially improving speed and relevance. In 'AND' mode, the AI searches all specified stores and combines the results, providing a more comprehensive but potentially slower search.
  </Accordion>
</AccordionGroup>

## See Also

- [Ask AI Block](/block-reference/ai/ask-ai)
- [AI Filter Block](/block-reference/ai/ai-filter)
- [Analyze Table Block](/block-reference/ai/analyze-table)

---

---
## ai/create-chart.mdx

---
id: create-chart
title: Create Chart Block
description: Generate data visualizations from tabular data using AI-powered natural language prompts
sidebarTitle: Create Chart
---

## Overview

The Create Chart Block leverages AI capabilities to generate data visualizations from tabular data based on natural language prompts. By providing a table of data and a descriptive prompt, you can instruct the AI to create various types of charts, graphs, and other visual representations of your data.
## Inputs

<ParamField path="Table" type="table" required>
  The input table containing the data to be visualized. Should be an array of objects, where each object represents a row in the table.
</ParamField>

<ParamField path="Prompt" type="string" required>
  A natural language prompt describing the desired chart or visualization. This input is only available if "Use Prompt Input" is enabled in settings. The prompt guides the AI in generating the appropriate code for creating the chart.
</ParamField>

## Outputs

<ResponseField name="Output" type="image">
  The resulting chart as a PNG image. Can be used directly in image tags or saved as an image file.
</ResponseField>

<ResponseField name="Duration" type="number">
  The time in milliseconds that the block took to execute.
</ResponseField>

## Editor Settings

<ParamField path="AI Model" type="string" default="default">
  The specific model to use for generating the chart code. Available models are dynamically populated based on the LLM provider configuration. Uses a custom LLM dropdown element.
</ParamField>

<ParamField path="Use Prompt Input" type="boolean" default={false}>
  When enabled, allows the prompt to be provided via an input port instead of being set in the settings.
</ParamField>

<ParamField path="Prompt" type="string">
  The prompt to use when "Use Prompt Input" is disabled. Describe the chart you would like to create given the input table. The AI will generate the code for you.
</ParamField>

## Error Handling

The block will retry failed attempts up to 3 times with exponential backoff:
- Minimum retry delay: 500ms
- Maximum retry delay: 5000ms 
- Retry factor: 2.5x
- Includes randomization

Error messages will be logged and the block will show:
- Code execution errors from the interpreter
- Missing configuration errors
- Response parsing errors

## Notes

- Uses seaborn library for chart generation
- Automatically handles date-time data formatting
- Optimizes charts for clarity and readability
- Includes proper axis labels, legends, and titles
- Limited to 2048 tokens for model responses

## Example Usage

1. Connect your input table to the Table input
2. Enable "Use Prompt Input" if you want to provide the prompt dynamically
3. Write a descriptive prompt like "Create a bar chart showing sales by month"
4. Select your desired AI model
5. The block will generate a PNG chart based on your specifications

## See Also

- [Analyze Table Block](/block-reference/ai/analyze-table)
- [AI Filter Block](/block-reference/ai/ai-filter)
- [Table Block](/block-reference/data/table)

---

---
## data/array.mdx

---
id: array
title: Array Block
description: Construct an array from one or more inputs of any type, with options for flattening and merging arrays
sidebarTitle: Array
---

## Overview

The Array Block is used to construct an array from one or more inputs of any type. It can also be used to merge multiple arrays into a single array using the `Flatten` setting.

By default, inputs will be flattened, so if any of the inputs are arrays themselves, they will be merged into the output array. This behavior can be disabled by unchecking the `Flatten` setting.
## Inputs

<ParamField path="Input [i]" type="any">
  An input to create the array from. If an array, will be flattened if the "Flatten" option is enabled. The number of inputs is dynamic based on how many connections there are.
</ParamField>

## Outputs

<ResponseField name="Output" type="any[]">
  The array created from the inputs.
</ResponseField>

<ResponseField name="Indices" type="number[]">
  The indices of the array. I.e. [0, 1, 2, 3, etc]. Useful for zipping with the output array to get the indexes.
</ResponseField>

<ResponseField name="Length" type="number">
  The length of the output array.
</ResponseField>

## Editor Settings

<ParamField path="Flatten" type="boolean" default={true}>
  If enabled, array inputs will be flattened before joining.
</ParamField>

<ParamField path="Deep" type="boolean" default={false}>
  If enabled, array inputs will be flattened recursively.
</ParamField>

## Example: Creating an Array from Multiple Inputs

1. Add an Array Block to your flow.
2. Connect three Text blocks with values `"Hello"`, `"World"`, and `"!"` to `Input 1`, `Input 2`, and `Input 3` of the Array Block respectively.

The `Output` of the Array Block will be `["Hello", "World", "!"]`.

## Example: Creating an Array from Array Inputs

1. Add an Array Block to your flow.
2. Connect two Array blocks with values `["One", "Two"]` and `["Three", "Four"]` to `Input 1` and `Input 2` of the Array Block.
3. Enable the `Flatten` setting.

The `Output` of the Array Block will be `["One", "Two", "Three", "Four"]`.

## Example: Using the Indices Output

1. Add an Array Block with value `["Apple", "Banana", "Cherry"]`.
2. Add a Text Block with text `"[{{index}}] - {{fruit}}"`.
3. Connect the `Output` of the Array Block to the `Fruit` input of the Text Block.
4. Connect the `Indices` output of the Array Block to the `Index` input of the Text Block.
5. Enable the `Split` setting on the Text Block.

The `Output` of the Text Block will be `["[0] - Apple", "[1] - Banana", "[2] - Cherry"]`.

## Flattening Arrays

The `Flatten` setting treats each element of an array input as a separate element to be added to the main array. The `Deep` setting recursively flattens all array inputs.

<Warning>
  With flatten disabled, you can get arrays of arrays. These are not well supported in Odella and you may have to use a [Code Block](/block-reference/data/code) to work with them.
</Warning>

## Error Handling

If an input is missing or null, the Array Block will simply ignore it during the array creation process.

## FAQ

<AccordionGroup>
  <Accordion title="What happens if I connect a non-array block to the Array Block?">
    The Array Block will treat it as a single element to be added to the array.
  </Accordion>

  <Accordion title="Can I connect an Array Block to another Array Block?">
    Yes. If `Flatten` is enabled, each element of the input array will be treated as a separate element. If disabled, the input array will be added as a single element.
  </Accordion>

  <Accordion title="What happens if an input is missing or null?">
    The Array Block will simply ignore it during the array creation process.
  </Accordion>
</AccordionGroup>

## See Also

- [Code Block](/block-reference/data/code)
- [Text Block](/block-reference/data/text)
- [Number Block](/block-reference/data/number)
- [Extract Object Path Block](/block-reference/data/extract-object-path)
- [Pop Block](/block-reference/data/pop)

---

---
## data/file.mdx

---
id: file
title: File Block
description: Upload and use file data in your workflow
sidebarTitle: File
---

## Overview

The File Block allows you to upload and use file data in your workflow. It supports various file types including PDF, Microsoft Word documents (.doc, .docx), and CSV files. This block is particularly useful when you need to work with external data or documents within your flow.
## Inputs

This block does not have any inputs.

## Outputs

<ResponseField name="data" type="file">
  The uploaded file data that can be used by other blocks in the workflow.
</ResponseField>

## Editor Settings

<ParamField path="File" type="file" accept="application/pdf, application/msword, application/vnd.openxmlformats-officedocument.wordprocessingml.document, text/csv">
  Upload a file from your local system. Supported file types include:
  - PDF files (.pdf)
  - Microsoft Word documents (.doc, .docx) 
  - CSV files (.csv)
</ParamField>

<ParamField path="Width" type="number" default={300}>
  The width of the block in pixels.
</ParamField>

<ParamField path="Hidden" type="boolean" default={true}>
  Whether the block is hidden in the block menu.
</ParamField>

## Example: Using a File Block with PDF Analysis

1. Add a File Block to your flow.
2. In the block's settings, click "Upload File" and select a PDF document from your local file system.
3. Connect the `data` output of the File Block to an AI block capable of analyzing PDF content, such as a custom PDF Analysis block.
4. Run your flow. The PDF content will be processed by the AI block for further analysis or extraction.

## Error Handling

The File Block will throw an error if:

- No file data is provided
- The file provider is not available
- The file upload fails or cannot be accessed

<Warning>
  Ensure that you have the necessary permissions to use and process the files you upload, especially when working with sensitive or copyrighted material.
</Warning>

## FAQ

<AccordionGroup>
  <Accordion title="What file types are supported?">
    The File Block supports:
    - PDF files (.pdf)
    - Microsoft Word documents (.doc, .docx)
    - CSV files (.csv)
  </Accordion>

  <Accordion title="Can I use the File Block to upload multiple files at once?">
    No, the File Block is designed to handle one file at a time. If you need to work with multiple files, you can use multiple File Blocks in your workflow.
  </Accordion>

  <Accordion title="How can I process the uploaded file data?">
    The file data output from the File Block can be connected to other blocks in your workflow that are capable of processing the specific file type. For example, you might connect a PDF file to a PDF text extraction block, or a CSV file to a data analysis block.
  </Accordion>
</AccordionGroup>

## See Also

- [Text Block](/block-reference/data/text)
- [Table Block](/block-reference/data/table)
- [Analyze Table Block](/block-reference/ai/analyze-table)

---

---
## data/bool.mdx

---
id: bool
title: Bool Block
description: Output a boolean constant or convert an input value into a boolean
sidebarTitle: Bool
---

## Overview

The Bool Block is used to output a boolean constant or convert an input value into a boolean. It's particularly useful when you need to create a boolean value for use in other blocks, such as the [If Block](/block-reference/data/if) or [If/Else Block](/block-reference/data/if-else).
## Inputs

<ParamField path="Input" type="any">
  The value to be converted to a boolean. This input is only available if "Use Value Input" is enabled.
</ParamField>

## Outputs

<ResponseField name="Value" type="boolean">
  The boolean value. If "Use Value Input" is enabled, this will be the input value converted to a boolean. Otherwise, outputs the constant value specified in settings.
</ResponseField>

## Editor Settings

<ParamField path="Value" type="boolean" default={false}>
  The constant boolean value to output. This setting is only available if "Use Value Input" is disabled.
</ParamField>

<ParamField path="Use Value Input" type="boolean" default={false}>
  If enabled, the block will convert an input value to a boolean. If disabled, the block will output the constant boolean value specified in the Value setting.
</ParamField>

<ParamField path="Width" type="number" default={130}>
  The width of the block in pixels.
</ParamField>

<ParamField path="Hidden" type="boolean" default={true}>
  Whether the block is hidden in the block menu.
</ParamField>

## Conversion Rules

The Bool Block follows JavaScript's rules for truthy and falsy values when converting input values to booleans. If no input is connected when "Use Value Input" is enabled, it will fall back to using the Value setting.

## Example: Using a Constant Boolean Value

1. Add a Bool Block to your flow.
2. Set the `Value` setting to `true`.
3. Run the flow. The `Value` output of the Bool Block will be `true`.

## Example: Converting an Input to a Boolean

1. Add a Bool Block to your flow.
2. Enable the `Use Value Input` setting.
3. Add a [Text Block](/block-reference/data/text) to your flow and set the text to `"Hello"`.
4. Connect the output of the Text Block to the `Input` of the Bool Block.
5. Run the flow. The `Value` output of the Bool Block will be `true`, because the string `"Hello"` is a truthy value in JavaScript.

## Error Handling

The Bool Block cannot error under normal circumstances. If "Use Value Input" is enabled and no input is connected, the block will fall back to using the Value setting.

## FAQ

<AccordionGroup>
  <Accordion title="What values are considered truthy and falsy in JavaScript?">
    The following values are considered falsy:
    - `false`
    - `0`
    - `''` (empty string)
    - `null`
    - `undefined`
    - `NaN`

    All other values are considered truthy.
  </Accordion>

  <Accordion title="What happens if no input is connected when Use Value Input is enabled?">
    The block will fall back to using the Value setting specified in the editor settings.
  </Accordion>
</AccordionGroup>

## See Also

- [If Block](/block-reference/data/if)
- [Match Block](/block-reference/data/match)
- [Text Block](/block-reference/data/text)
- [Array Block](/block-reference/data/array)
- [Number Block](/block-reference/data/number)

---

---
## data/number.mdx

---
id: number
title: Number Block
description: Output a constant number value or convert an input value into a number
sidebarTitle: Number
---

## Overview

The Number Block is used to output a constant number value or convert an input value into a number. It can also be configured to round the number to a specified number of decimal places.
## Inputs

<ParamField path="input" type="any">
  The value to be converted into a number. This input is only available if the "Use Value Input" setting is enabled. If the input cannot be converted to a number, the block will use the Value setting instead.
</ParamField>

## Outputs

<ResponseField name="value" type="number">
  The output number value. This can either be a constant value or a converted input value.
</ResponseField>

## Editor Settings

<ParamField path="value" type="number" default={0}>
  The constant number value to be outputted. This value is used when either:
  - The "Use Value Input" setting is disabled
  - The "Use Value Input" setting is enabled but no input is connected
  - The "Use Value Input" setting is enabled but the input cannot be converted to a number
</ParamField>

<ParamField path="useValueInput" type="boolean">
  When enabled, shows an input port that accepts any value and attempts to convert it to a number.
</ParamField>

<ParamField path="round" type="boolean" default={false}>
  When enabled, rounds the output number to the specified number of decimal places.
</ParamField>

<ParamField path="roundTo" type="number" default={0}>
  The number of decimal places to round to when the "Round" setting is enabled.
</ParamField>

## Example: Output a constant number

1. Add a Number Block to your flow.
2. Set the `Value` to `123.456`.
3. Run the flow. The `value` output of the Number Block will be `123.456`.
## Example: Convert a string to a number

1. Add a Text Block to your flow and set the text to `"123.456"`.
2. Add a Number Block and enable the `Use Value Input` setting.
3. Connect the Text Block to the `input` of the Number Block.
4. Run the flow. The `value` output of the Number Block will be `123.456`.
## Example: Round a number

1. Add a Number Block to your flow.
2. Set the `Value` to `123.456`.
3. Enable the `Round` setting and set `Round To` to `2`.
4. Run the flow. The `value` output of the Number Block will be `123.46`.
## Error Handling

The Number Block will not error under normal circumstances. If the input value cannot be converted to a number when "Use Value Input" is enabled, it will default to using the Value setting.

## FAQ

<AccordionGroup>
  <Accordion title="Can I use the Number Block to convert a boolean to a number?">
    Yes, you can use the Number Block to convert a boolean to a number. A `true` value will be converted to `1` and a `false` value will be converted to `0`.
  </Accordion>

  <Accordion title="What happens if I connect a non-numeric value to the Input of the Number Block?">
    The Number Block will attempt to convert the input value to a number. If the conversion is not possible, the block will default to using the Value setting.
  </Accordion>

  <Accordion title="Can I use the Number Block to round a number to an integer?">
    Yes, you can use the Number Block to round a number to an integer by enabling the `Round` setting and setting `Round To` to `0`.
  </Accordion>
</AccordionGroup>

## See Also

- [Text Block](/block-reference/data/text)
- [Bool Block](/block-reference/data/bool)
- [Compare Block](/block-reference/logic/compare)

---

---
## data/text.mdx

---
id: text
title: Text Block
description: Output a string of text with dynamic interpolation using {{tags}}
sidebarTitle: Text
---

## Overview

The Text Block outputs a string of text and can interpolate values using `{{tags}}` within the text. The inputs are dynamically generated based on the interpolation tags used in the text.
## Inputs

<ParamField path="(Dynamic)" type="string">
  The inputs are dynamically generated based on the interpolation tags used in the text. For example, if the text contains `{{name}}`, an input named `name` will be created. All inputs are optional and accept string values. If an input is not connected, its tag will be replaced with an empty string.
</ParamField>

## Outputs

<ResponseField name="output" type="string">
  The output text after interpolating all input values into their corresponding tags.
</ResponseField>

## Editor Settings

<ParamField path="text" type="code" language="prompt-interpolation-markdown" default="{{input}}">
  The text to output. You can use interpolation tags in the format `{{tag}}` to insert input values. The text supports markdown formatting and will be displayed with syntax highlighting in the editor.
</ParamField>

<ParamField path="width" type="number" default={250}>
  The width of the block in pixels.
</ParamField>

<ParamField path="hidden" type="boolean" default={true}>
  Whether the block is hidden in the block menu.
</ParamField>

## Example: Simple Text Output

1. Add a Text Block to your flow
2. Set the text to `Hello World!`
3. Run the flow. The output will be `Hello World!`
## Example: Using Interpolation

1. Add a Text Block and set the text to `Hello {{name}}!`
2. Add another Text Block with value "World"
3. Connect the second block's output to the `name` input of the first block
4. Run the flow. The output will be `Hello World!`
## Error Handling

The Text Block handles missing or null inputs gracefully by replacing their tags with empty strings. No errors will be thrown during normal operation.

## FAQ

<AccordionGroup>
  <Accordion title="Can I use multiple interpolation tags?">
    Yes, you can use any number of unique interpolation tags in your text. Each tag will create a corresponding input on the block.
  </Accordion>

  <Accordion title="What happens if an input is missing?">
    If an input is not connected or its value is null, the corresponding tag will be replaced with an empty string in the output.
  </Accordion>

  <Accordion title="Does the Text Block support markdown?">
    Yes, the text content supports markdown formatting and will be displayed with syntax highlighting in the editor.
  </Accordion>
</AccordionGroup>

## See Also

- [Object Block](/block-reference/data/object)
- [Number Block](/block-reference/data/number)
- [Code Block](/block-reference/advanced/code)

---

---
## data/image.mdx

---
id: image
title: Image Block
description: Define a static image for use with other nodes. Can convert a binary type into an image type.
sidebarTitle: Image
---

## Overview

The Image Block is used to define a static image for use with other blocks. It supports PNG, JPEG, and JPG formats and allows you to select an image file from your local system.
## Inputs

This block does not have any inputs.

## Outputs

<ResponseField name="image" type="image">
  The image that was loaded or converted from the input data.
</ResponseField>

## Editor Settings

<ParamField path="Image" type="file" accept="image/png,image/jpeg,image/jpg">
  The image file to be used. Click to select an image from your local file system.
</ParamField>

<ParamField path="Width" type="number" default={250}>
  The width of the block in pixels.
</ParamField>

<ParamField path="Hidden" type="boolean" default={true}>
  Whether the block is hidden in the block menu.
</ParamField>

## Example: Using a Static Image

1. Add an Image Block to your flow
2. In the block's settings, click to select an image file from your local file system
3. Connect the `image` output to another block that accepts image inputs
4. Run your flow. The selected image will be passed to the connected block.
## Error Handling

The Image Block will throw an error if:

- No image data is provided
- The file provider is not available
- The image file cannot be accessed or loaded

<Warning>
  Ensure that you have selected a valid image file and have the necessary permissions to access it.
</Warning>

## FAQ

<AccordionGroup>
  <Accordion title="What image formats are supported?">
    The Image Block supports:
    - PNG (.png)
    - JPEG/JPG (.jpeg, .jpg)
  </Accordion>

  <Accordion title="Can I use the Image Block to convert binary data to an image?">
    Yes, the Image Block can convert binary data into an image type that can be used by other blocks in your workflow.
  </Accordion>

  <Accordion title="What happens if no image is selected?">
    The block will throw an error if no image data is provided. You must select an image file for the block to function properly.
  </Accordion>
</AccordionGroup>

## See Also

- [File Block](/block-reference/data/file)
- [Audio Block](/block-reference/data/audio)
- [Text Block](/block-reference/data/text)

---

---
## data/audio.mdx

---
id: audio
title: Audio Block (requires support to enable)
description: We have the ability to define audio samples and convert binary data to audio type, but this requires support to enable
sidebarTitle: Audio
---

## Overview

The Audio Block is used to define an audio sample for use with other blocks. It can also convert a binary type into an audio type. The block can either take an input that represents the audio data or use an audio file specified in the block's settings.

## Inputs

<ParamField path="Data" type="binary">
  The binary data representing the audio. This input is only available if the "Use Data Input" setting is enabled.
</ParamField>

## Outputs

<ResponseField name="Audio Data" type="audio">
  The audio data converted into a format that can be used by other blocks that accept audio data as input. Contains a Uint8Array of the audio data.
</ResponseField>

## Editor Settings

<ParamField path="Audio File" type="file" accept="audio/*">
  The audio file to be used as the audio data. This file will be stored as a base64-encoded string and converted to a Uint8Array during execution.
</ParamField>

<ParamField path="Use Data Input" type="boolean" default={false}>
  If enabled, the block will use the data from the "Data" input port as the audio data. If disabled, the block will use the data from the audio file specified in the "Audio File" setting.
</ParamField>

<ParamField path="Width" type="number" default={300}>
  The width of the block in pixels.
</ParamField>

## Example: Using an Audio Block with a File

1. Add an Audio Block to your flow.
2. In the block's settings, click "Pick File" and select an audio file from your local file system.

## Error Handling

The Audio Block will throw an error if:

- The "Use Data Input" setting is enabled but no data is provided to the "Data" input port.
- The "Use Data Input" setting is disabled but no audio file is specified in the "Audio File" setting.
- The provided audio data (either from the "Data" input or the specified audio file) cannot be converted to a Uint8Array.

<Warning>
  Ensure that the audio data is in a format that can be converted to a Uint8Array to avoid errors.
</Warning>

## FAQ

<AccordionGroup>
  <Accordion title="What audio file formats are supported by the Audio Block?">
    The Audio Block accepts any audio file format (audio/*). However, the audio data should ultimately be convertible to a Uint8Array. The specific audio file formats that can be used will depend on what other blocks you are connecting the Audio Block to.
  </Accordion>

  <Accordion title="Can I use the Audio Block to play audio?">
    The Audio Block shows a playback bar on the Odella UI, but otherwise, it cannot be used to play back audio during the flow's execution.
  </Accordion>
</AccordionGroup>

## See Also

- [Image Block](/block-reference/data/image)
- [Text Block](/block-reference/data/text)
- [Number Block](/block-reference/data/number)
- [Bool Block](/block-reference/data/bool)
- [External Call Block](/block-reference/data/external-call)

---

---
## data/date.mdx

---
id: date
title: Date Block
description: Select a date value for use in your workflow
sidebarTitle: Date
---

## Overview

The Date Block provides a date picker to select a specific date value that can be used in your workflow. The selected date is output in ISO string format.
## Inputs

This block does not have any inputs.

## Outputs

<ResponseField name="data" type="datetime">
  The selected date value in ISO string format.
</ResponseField>

## Editor Settings

<ParamField path="Date" type="datePicker">
  The date value to output. Uses a date picker interface to select a date.
</ParamField>

<ParamField path="Width" type="number" default={300}>
  The width of the block in pixels.
</ParamField>

<ParamField path="Hidden" type="boolean" default={true}>
  Whether the block is hidden in the block menu.
</ParamField>

## Example: Using a Date Block

1. Add a Date Block to your flow
2. Use the date picker to select your desired date
3. Connect the `data` output to another block that accepts datetime values
4. Run the flow. The selected date will be passed to the connected block.

## Error Handling

The Date Block will throw an error if:

- The selected date is invalid
- The date cannot be converted to ISO string format

<Warning>
  Ensure the selected date is valid to avoid errors in blocks consuming the date value.
</Warning>

## FAQ

<AccordionGroup>
  <Accordion title="What format is the date output in?">
    The Date Block outputs dates in ISO string format (e.g. "2024-01-01T00:00:00.000Z").
  </Accordion>

  <Accordion title="Can I input dates programmatically?">
    No, the Date Block only allows date selection through its date picker interface. For programmatic date handling, consider using other blocks that accept date inputs.
  </Accordion>
</AccordionGroup>

## See Also

- [Number Block](/block-reference/data/number)
- [Text Block](/block-reference/data/text)
- [Bool Block](/block-reference/data/bool)

---

---
## data/object.mdx

---
id: object
title: Object Block
description: Create an object from input values and a JSON template
sidebarTitle: Object
---

## Overview

The Object Block creates an object from input values and a JSON template. It automatically escapes input values and inserts them into the template, supporting any data type as input and outputting an object.
## Inputs

<ParamField path="(Dynamic)" type="any">
  Input values to be inserted into the JSON template. Input names are dynamically generated from the JSON template based on values wrapped in double curly braces (e.g. `{{input}}`). Non-string inputs are automatically converted to strings.
</ParamField>

## Outputs

<ResponseField name="output" type="object | object[]">
  The object or array created from the input values and JSON template. The type will be `object[]` if the template defines an array, otherwise it will be `object`.
</ResponseField>

## Editor Settings

<ParamField path="jsonTemplate" type="code" language="json" default='{ "key": "{{input}}" }'>
  The JSON template for creating the object. Input values are inserted into this template using double curly brace syntax (e.g. `{{input}}`). The template must be valid JSON.

  Values wrapped in quotes (e.g. `"{{input}}"`) will be treated as strings and escaped appropriately. Values without quotes will be inserted directly as JSON values.
</ParamField>

<ParamField path="width" type="number" default={200}>
  The width of the block in pixels.
</ParamField>

<ParamField path="hidden" type="boolean" default={true}>
  Whether the block is hidden in the block menu.
</ParamField>

## Example: Creating an object from multiple inputs

1. Add an Object Block and set the JSON Template to:
   ```json
   {
     "name": "{{name}}",
     "age": {{age}},
     "job": "{{job}}"
   }
   ```
2. Add two Text Blocks with values "John Doe" and "Engineer". Connect to `name` and `job` inputs.
3. Add a Number Block with value 30. Connect to `age` input.
4. Run the flow. The Object Block output will be:
   ```json
   {
     "name": "John Doe",
     "age": 30,
     "job": "Engineer"
   }
   ```
## Error Handling

The Object Block will error if:
- The JSON Template is not a valid JSON string
- The interpolated JSON string (after inserting input values) is not valid JSON

## FAQ

<AccordionGroup>
  <Accordion title="Can I use the Object Block to create an array?">
    Yes, set the JSON Template to a valid JSON array string:
    ```json
    ["{{value1}}", "{{value2}}", "{{value3}}"]
    ```
  </Accordion>

  <Accordion title="How are input values escaped?">
    Input values are automatically escaped based on whether they appear in quotes in the template:
    - Values in quotes (e.g. `"{{input}}"`) are escaped as strings using `JSON.stringify()`
    - String values in quotes get a single `JSON.stringify()`
    - Non-string values in quotes get a double `JSON.stringify()` to properly escape them
    - Values without quotes are stringified directly as JSON values
  </Accordion>

  <Accordion title="What happens to null or undefined input values?">
    If an input value is null or undefined, it will be converted to `null` in the output JSON.
  </Accordion>
</AccordionGroup>

## See Also

- [Array Block](/block-reference/data/array)
- [Text Block](/block-reference/data/text)
- [Extract Object Path Block](/block-reference/data/extract-object-path)
- [Code Block](/block-reference/data/code)

---

---
## loaders/read-table.mdx

---
id: read-table
title: Read Table Block
description: Read and parse CSV files into table data structures
sidebarTitle: Read Table
---
## Overview
The Read Table Block is designed to read and parse CSV (Comma-Separated Values) files, converting them into structured table data that can be easily manipulated and analyzed within your workflow. This block is particularly useful for processing tabular data stored in CSV format.

## Inputs

<ParamField path="file" type="file" required>
  The input CSV file to be read and parsed. Must have a media type of "text/csv". This should be a file data value, typically provided by a File block or another block that outputs file data.
</ParamField>

## Outputs

<ResponseField name="output" type="table">
  A table data structure containing the parsed CSV data. Each row in the table corresponds to a row in the CSV file, with columns representing the CSV fields.
</ResponseField>

## Error Handling

- If the input file is missing or invalid, the block will return an error.
- If the file lacks a media type, the block will throw an error.
- If the file's media type is not "text/csv", the block will throw an error.
- If a FileProvider is needed to load from URL but not available, the block will throw an error.
- If there are issues parsing the CSV file, the block will fail and provide error details.

<Warning>
  Only CSV files with media type "text/csv" are currently supported. Ensure your input files are in CSV format with the correct media type.
</Warning>

## Example: Reading a CSV File

1. Add a Read Table block to your flow.
2. Connect a File block containing a CSV file to the `file` input.
3. Run your flow. The block will parse the CSV and output a table data structure.## FAQ

<AccordionGroup>
  <Accordion title="What file types are supported?">
    The Read Table block currently only supports CSV files with the media type "text/csv".
  </Accordion>

  <Accordion title="How does the block handle large CSV files?">
    The block reads and parses the entire CSV file into memory. For very large files, consider available memory and processing time implications.
  </Accordion>

  <Accordion title="What happens if the CSV file is malformed?">
    If there are issues parsing the CSV file due to malformed data or inconsistent structure, the block will fail and provide error details.
  </Accordion>
</AccordionGroup>

## See Also

- [File Block](/block-reference/data/file)
- [Analyze Table Block](/block-reference/ai/analyze-table)
- [Table Block](/block-reference/data/table)

---

---
## loaders/read-text.mdx

---
id: read-text
title: Read Text Block
description: Read the contents of a file as text or markdown
sidebarTitle: Read Text
---
## Overview
The Read Text Block is used to read and extract text content from PDF and DOCX files, outputting it as either plain text or markdown. This block is particularly useful for processing text-based documents within your workflow.

## Inputs

<ParamField path="file" type="file" required>
  The input file to be read. Must be a PDF or DOCX file with a valid media type. This should be a file data value, typically provided by a File block or another block that outputs file data.
</ParamField>

## Outputs

<ResponseField name="output" type="string">
  The extracted text content from the file, formatted as either plain text or markdown based on the Output Text Format setting.
</ResponseField>

## Editor Settings

<ParamField path="Output Text Format" type="string" default="markdown">
  Determines how the file content is interpreted and output. Options are:
  - "Markdown": Interprets and outputs the file content as markdown
  - "Text": Outputs the file content as plain text
</ParamField>

## Example: Reading a PDF File

1. Add a Read Text block to your flow.
2. Connect a File block containing a PDF or DOCX file to the `file` input.
3. In the block settings, select your desired Output Text Format.
4. Run your flow. The block will extract and output the text content.

## Error Handling

- If the input file is missing or invalid, the block will return an error.
- If the file lacks a media type, the block will throw an error.
- If a FileProvider is needed to load from URL but not available, the block will throw an error.
- If there are issues reading the file (e.g., file permissions, corrupted file), the block will fail and provide error details.

<Warning>
  Only PDF and DOCX files are currently supported. Ensure your input files are in one of these formats and have valid media types.
</Warning>

## FAQ

<AccordionGroup>
  <Accordion title="What file types are supported?">
    The Read Text block currently supports:
    - PDF files (application/pdf)
    - Microsoft Word documents (.doc and .docx)
  </Accordion>

  <Accordion title="How does the Markdown output differ from Text?">
    When set to Markdown output, the block will preserve formatting and structure from the original document in markdown syntax. Text output provides raw text content without formatting.
  </Accordion>

  <Accordion title="How does the block handle large files?">
    The block includes retry logic for processing large files, with configurable timeout and retry settings. For extremely large files, consider potential memory usage and processing time implications.
  </Accordion>
</AccordionGroup>

## See Also

- [File Block](/block-reference/data/file)
- [Text To File](/block-reference/draft/text-to-file)

---

---
## loaders/read-binary.mdx

---
id: read-binary
title: Read Binary Block
description: Read the contents of a file as binary data
sidebarTitle: Read Binary
---
## Overview

The Read Binary Block allows you to read the contents of a file as raw binary data. This is particularly useful when working with non-text files or when you need to process file contents in their original binary format.## Inputs

<ParamField path="file" type="file" required>
  The input file to be read as binary. The file must have a valid media type.
</ParamField>

## Outputs

<ResponseField name="output" type="binary">
  The raw binary content of the input file as a Uint8Array.
</ResponseField>

## Editor Settings

This block does not have any configurable settings in the editor.

## Example: Reading an Image File as Binary

1. Add a Read Binary block to your flow.
2. Connect a File block containing an image file to the `file` input of the Read Binary block.
3. Run your flow. The block will output the raw binary data of the image file.

## Error Handling

- If the input file is missing or invalid, the block will return an error.
- If the file is missing a media type, the block will throw an error.
- If a FileProvider is needed to load from URL but not available, the block will throw an error.
- If there are issues reading the file (e.g., file permissions, corrupted file), the block will fail and provide error details.

<Warning>
  Be cautious when working with large files, as reading them entirely into memory as binary data may consume significant resources.
</Warning>

## FAQ

<AccordionGroup>
  <Accordion title="What types of files can I read with this block?">
    The Read Binary block can read any type of file, including text files, images, audio files, executables, and more. It treats all files as raw binary data.
  </Accordion>

  <Accordion title="How is this different from the Read File block?">
    While the Read File block is optimized for reading text files and can perform encoding conversions, the Read Binary block reads the raw binary content of any file without any interpretation or conversion.
  </Accordion>

  <Accordion title="Is there a size limit for files that can be read?">
    The block itself doesn't impose a specific size limit, but reading very large files may be limited by available memory and system resources. For extremely large files, consider using streaming or chunking approaches.
  </Accordion>
</AccordionGroup>

## See Also

- [Read File Block](/block-reference/loaders/read-file)
- [File Block](/block-reference/data/file)
- [Write Binary Block](/block-reference/io/write-binary)

---

